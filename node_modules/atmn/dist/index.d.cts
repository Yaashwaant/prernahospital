import { z } from 'zod/v4';

declare const ProductSchema: z.ZodObject<{
    id: z.ZodString;
    name: z.ZodString;
    is_add_on: z.ZodOptional<z.ZodPrefault<z.ZodBoolean>>;
    is_default: z.ZodOptional<z.ZodPrefault<z.ZodBoolean>>;
    items: z.ZodArray<z.ZodObject<{
        type: z.ZodOptional<z.ZodNullable<z.ZodEnum<{
            feature: "feature";
            priced_feature: "priced_feature";
        }>>>;
        feature_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        included_usage: z.ZodOptional<z.ZodNullable<z.ZodUnion<readonly [z.ZodNumber, z.ZodLiteral<"inf">]>>>;
        interval: z.ZodOptional<z.ZodNullable<z.ZodEnum<{
            minute: "minute";
            hour: "hour";
            day: "day";
            week: "week";
            month: "month";
            quarter: "quarter";
            semi_annual: "semi_annual";
            year: "year";
        }>>>;
        usage_model: z.ZodOptional<z.ZodNullable<z.ZodEnum<{
            prepaid: "prepaid";
            pay_per_use: "pay_per_use";
        }>>>;
        price: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
        tiers: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodObject<{
            amount: z.ZodNumber;
            to: z.ZodUnion<readonly [z.ZodNumber, z.ZodLiteral<"inf">]>;
        }, z.core.$strip>>>>;
        billing_units: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
        reset_usage_when_enabled: z.ZodOptional<z.ZodBoolean>;
        entity_feature_id: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    free_trial: z.ZodOptional<z.ZodObject<{
        duration: z.ZodEnum<{
            day: "day";
            month: "month";
            year: "year";
        }>;
        length: z.ZodNumber;
        unique_fingerprint: z.ZodBoolean;
        card_required: z.ZodBoolean;
    }, z.core.$strip>>;
    archived: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
declare const FeatureSchema: z.ZodObject<{
    id: z.ZodString;
    name: z.ZodOptional<z.ZodString>;
    type: z.ZodEnum<{
        boolean: "boolean";
        single_use: "single_use";
        continuous_use: "continuous_use";
        credit_system: "credit_system";
    }>;
    credit_schema: z.ZodOptional<z.ZodArray<z.ZodObject<{
        metered_feature_id: z.ZodString;
        credit_cost: z.ZodNumber;
    }, z.core.$strip>>>;
    archived: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
type Feature = z.infer<typeof FeatureSchema>;
type Product = z.infer<typeof ProductSchema>;

declare const ProductItemIntervalEnum: z.ZodEnum<{
    minute: "minute";
    hour: "hour";
    day: "day";
    week: "week";
    month: "month";
    quarter: "quarter";
    semi_annual: "semi_annual";
    year: "year";
}>;
declare const UsageModelEnum: z.ZodEnum<{
    prepaid: "prepaid";
    pay_per_use: "pay_per_use";
}>;
type ProductItemInterval = z.infer<typeof ProductItemIntervalEnum>;
type UsageModel = z.infer<typeof UsageModelEnum>;
declare const ProductItemSchema: z.ZodObject<{
    type: z.ZodOptional<z.ZodNullable<z.ZodEnum<{
        feature: "feature";
        priced_feature: "priced_feature";
    }>>>;
    feature_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    included_usage: z.ZodOptional<z.ZodNullable<z.ZodUnion<readonly [z.ZodNumber, z.ZodLiteral<"inf">]>>>;
    interval: z.ZodOptional<z.ZodNullable<z.ZodEnum<{
        minute: "minute";
        hour: "hour";
        day: "day";
        week: "week";
        month: "month";
        quarter: "quarter";
        semi_annual: "semi_annual";
        year: "year";
    }>>>;
    usage_model: z.ZodOptional<z.ZodNullable<z.ZodEnum<{
        prepaid: "prepaid";
        pay_per_use: "pay_per_use";
    }>>>;
    price: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    tiers: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodObject<{
        amount: z.ZodNumber;
        to: z.ZodUnion<readonly [z.ZodNumber, z.ZodLiteral<"inf">]>;
    }, z.core.$strip>>>>;
    billing_units: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    reset_usage_when_enabled: z.ZodOptional<z.ZodBoolean>;
    entity_feature_id: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
type ProductItem = z.infer<typeof ProductItemSchema>;

declare const product: (p: Product) => {
    id: string;
    name: string;
    items: {
        type?: "feature" | "priced_feature" | null | undefined;
        feature_id?: string | null | undefined;
        included_usage?: number | "inf" | null | undefined;
        interval?: "minute" | "hour" | "day" | "week" | "month" | "quarter" | "semi_annual" | "year" | null | undefined;
        usage_model?: "prepaid" | "pay_per_use" | null | undefined;
        price?: number | null | undefined;
        tiers?: {
            amount: number;
            to: number | "inf";
        }[] | null | undefined;
        billing_units?: number | null | undefined;
        reset_usage_when_enabled?: boolean | undefined;
        entity_feature_id?: string | undefined;
    }[];
    is_add_on?: boolean | undefined;
    is_default?: boolean | undefined;
    free_trial?: {
        duration: "day" | "month" | "year";
        length: number;
        unique_fingerprint: boolean;
        card_required: boolean;
    } | undefined;
    archived?: boolean | undefined;
};
declare const feature: (f: Feature) => {
    id: string;
    type: "boolean" | "single_use" | "continuous_use" | "credit_system";
    name?: string | undefined;
    credit_schema?: {
        metered_feature_id: string;
        credit_cost: number;
    }[] | undefined;
    archived?: boolean | undefined;
};
declare const featureItem: ({ feature_id, included_usage, interval, reset_usage_when_enabled, entity_feature_id, }: {
    feature_id: string;
    included_usage?: number | "inf";
    interval?: ProductItemInterval;
    reset_usage_when_enabled?: boolean;
    entity_feature_id?: string;
}) => ProductItem;
declare const pricedFeatureItem: ({ feature_id, price, tiers, interval, included_usage, billing_units, usage_model, reset_usage_when_enabled, entity_feature_id, }: {
    feature_id: string;
    price?: number;
    tiers?: {
        to: number | "inf";
        amount: number;
    }[];
    interval?: ProductItemInterval;
    included_usage?: number;
    billing_units?: number;
    usage_model?: UsageModel;
    reset_usage_when_enabled?: boolean;
    entity_feature_id?: string;
}) => ProductItem;
declare const priceItem: ({ price, interval, }: {
    price: number;
    interval?: ProductItemInterval;
}) => ProductItem;

type Infinity = "infinity";
type AutumnConfig = {
    products: Product[];
    features: Feature[];
};

export { type AutumnConfig, type Feature, type Infinity, type Product, type ProductItem, feature, featureItem, priceItem, pricedFeatureItem, product };
