#!/usr/bin/env node
import chalk8 from 'chalk';
import { program } from 'commander';
import open from 'open';
import { confirm, input, password, select } from '@inquirer/prompts';
import dotenv from 'dotenv';
import fs from 'fs';
import yoctoSpinner from 'yocto-spinner';
import axios, { AxiosError } from 'axios';
import prettier from 'prettier';
import path, { resolve } from 'path';
import createJiti from 'jiti';
import { pathToFileURL } from 'url';
import { execSync } from 'child_process';
import { z } from 'zod/v4';

var notNullish = (value) => value !== null && value !== void 0;
var nullish = (value) => value === null || value === void 0;
var isLocalFlag = () => {
  const localFlag = process.argv.includes("--local") || process.argv.includes("-l");
  return localFlag;
};
function idToVar({
  id,
  prefix = "product"
}) {
  const processed = id.replace(/[-_](.)/g, (_, letter) => letter.toUpperCase()).replace(/[^a-zA-Z0-9_$]/g, "");
  if (/^[0-9]/.test(processed)) {
    return `${prefix}${processed}`;
  }
  if (/^[^a-zA-Z_$]/.test(processed)) {
    return `${prefix}${processed}`;
  }
  return processed;
}
async function upsertEnvVar(filePath, varName, newValue) {
  const content = fs.readFileSync(filePath, "utf-8");
  const lines = content.split("\n");
  let found = false;
  for (let i = 0; i < lines.length; i++) {
    if (lines[i]?.startsWith(`${varName}=`)) {
      const shouldOverwrite = await confirm({
        message: `${varName} already exists in .env. Overwrite?`,
        default: false
      });
      if (shouldOverwrite) {
        lines[i] = `${varName}=${newValue}`;
        found = true;
        break;
      }
    }
  }
  if (!found) {
    lines.push(`${varName}=${newValue}`);
  }
  fs.writeFileSync(filePath, lines.join("\n"));
}
async function storeToEnv(prodKey, sandboxKey) {
  const envPath = `${process.cwd()}/.env`;
  const envLocalPath = `${process.cwd()}/.env.local`;
  const envVars = `AUTUMN_PROD_SECRET_KEY=${prodKey}
AUTUMN_SECRET_KEY=${sandboxKey}
`;
  if (fs.existsSync(envPath)) {
    await upsertEnvVar(envPath, "AUTUMN_PROD_SECRET_KEY", prodKey);
    await upsertEnvVar(envPath, "AUTUMN_SECRET_KEY", sandboxKey);
    console.log(chalk8.green(".env file found. Updated keys."));
  } else if (fs.existsSync(envLocalPath)) {
    fs.writeFileSync(envPath, envVars);
    console.log(
      chalk8.green(
        ".env.local found but .env not found. Created new .env file and wrote keys."
      )
    );
  } else {
    fs.writeFileSync(envPath, envVars);
    console.log(
      chalk8.green(
        "No .env or .env.local file found. Created new .env file and wrote keys."
      )
    );
  }
}
function getEnvVar(parsed, prodFlag) {
  if (prodFlag) return parsed["AUTUMN_PROD_SECRET_KEY"];
  return parsed["AUTUMN_SECRET_KEY"];
}
function readFromEnv(options) {
  const envPath = `${process.cwd()}/.env`;
  const envLocalPath = `${process.cwd()}/.env.local`;
  const prodFlag = process.argv.includes("--prod") || process.argv.includes("-p");
  if (prodFlag && process.env["AUTUMN_PROD_SECRET_KEY"]) {
    return process.env["AUTUMN_PROD_SECRET_KEY"];
  }
  if (!prodFlag && process.env["AUTUMN_SECRET_KEY"]) {
    return process.env["AUTUMN_SECRET_KEY"];
  }
  let secretKey;
  if (fs.existsSync(envPath) && !secretKey)
    secretKey = getEnvVar(
      dotenv.parse(fs.readFileSync(envPath, "utf-8")),
      prodFlag
    );
  if (fs.existsSync(envLocalPath) && !secretKey)
    secretKey = getEnvVar(
      dotenv.parse(fs.readFileSync(envLocalPath, "utf-8")),
      prodFlag
    );
  if (!secretKey && !options?.bypass) {
    if (prodFlag) {
      console.error(
        "[Error] atmn uses the AUTUMN_PROD_SECRET_KEY to call the Autumn production API. Please add it to your .env file or run `atmn login` to authenticate."
      );
      process.exit(1);
    } else {
      console.error(
        "[Error] atmn uses the AUTUMN_SECRET_KEY to call the Autumn sandbox API. Please add it to your .env (or .env.local) file or run `atmn login` to authenticate."
      );
      process.exit(1);
    }
  }
  return secretKey;
}
function initSpinner(message) {
  const spinner = yoctoSpinner({
    text: message
  });
  spinner.start();
  return spinner;
}
async function isSandboxKey(apiKey) {
  const prefix = apiKey.split("am_sk_")[1]?.split("_")[0];
  if (prefix === "live") {
    return false;
  } else if (prefix === "test") return true;
  else throw new Error("Invalid API key");
}

// source/constants.ts
var FRONTEND_URL = "http://app.useautumn.com";
var BACKEND_URL = "https://api.useautumn.com";
var DEFAULT_CONFIG = `import {
	feature,
	product,
	priceItem,
	featureItem,
	pricedFeatureItem,
} from 'atmn';

export const seats = feature({
	id: 'seats',
	name: 'Seats',
	type: 'continuous_use',
});

export const messages = feature({
	id: 'messages',
	name: 'Messages',
	type: 'single_use',
});

export const pro = product({
	id: 'pro',
	name: 'Pro',
	items: [
		// 500 messages per month
		featureItem({
			feature_id: messages.id,
			included_usage: 500,
			interval: 'month',
		}),

		// $10 per seat per month
		pricedFeatureItem({
			feature_id: seats.id,
			price: 10,
			interval: 'month',
		}),

		// $50 / month
		priceItem({
			price: 50,
			interval: 'month',
		}),
	],
});
`;

// source/core/api.ts
var INTERNAL_BASE = BACKEND_URL;
var EXTERNAL_BASE = `${BACKEND_URL}/v1`;
async function request({
  method,
  base,
  path: path2,
  data,
  headers,
  customAuth,
  throwOnError = true,
  secretKey,
  queryParams,
  bypass
}) {
  if (isLocalFlag()) {
    INTERNAL_BASE = "http://localhost:8080";
    EXTERNAL_BASE = "http://localhost:8080/v1";
    if (base) {
      base = base.replace(BACKEND_URL, "http://localhost:8080");
    }
  }
  const apiKey = secretKey || readFromEnv({ bypass });
  try {
    const response = await axios.request({
      method,
      url: `${base}${path2}`,
      data,
      params: queryParams,
      headers: {
        "Content-Type": "application/json",
        "X-API-Version": "1.2.0",
        ...headers,
        Authorization: customAuth || `Bearer ${apiKey}`
      }
    });
    return response.data;
  } catch (error) {
    if (throwOnError) {
      throw error;
    }
    console.error(`
${chalk8.bgRed.white.bold("  API REQUEST FAILED  ")}`);
    const methodPath = `${method.toUpperCase()} ${base}${path2}`;
    console.error(chalk8.red(methodPath));
    if (error instanceof AxiosError) {
      const status = error.response?.status;
      const data2 = error.response?.data;
      const code = data2?.code || data2?.error || "unknown_error";
      const message = data2?.message || error.message || "An unknown error occurred";
      if (status) {
        console.error(chalk8.redBright(`[${status}] ${code}`));
      }
      console.error(chalk8.red(message));
    } else if (error instanceof Error) {
      console.error(chalk8.red(error.message));
    } else {
      console.error(chalk8.red(String(error)));
    }
    process.exit(1);
  }
}
async function internalRequest({
  method,
  path: path2,
  data,
  headers,
  customAuth
}) {
  return await request({
    method,
    base: INTERNAL_BASE,
    path: path2,
    data,
    headers,
    customAuth,
    bypass: true
  });
}
async function externalRequest({
  method,
  path: path2,
  data,
  headers,
  customAuth,
  throwOnError = false,
  queryParams
}) {
  return await request({
    method,
    base: EXTERNAL_BASE,
    path: path2,
    data,
    headers,
    customAuth,
    throwOnError,
    queryParams
  });
}
async function deleteFeature({ id }) {
  return await externalRequest({
    method: "DELETE",
    path: `/features/${id}`
  });
}
async function deleteProduct({
  id,
  allVersions
}) {
  return await externalRequest({
    method: "DELETE",
    path: `/products/${id}`,
    queryParams: { all_versions: !!allVersions }
  });
}
async function updateCLIStripeKeys({
  stripeSecretKey,
  autumnSecretKey
}) {
  return await request({
    base: EXTERNAL_BASE,
    method: "POST",
    path: "/organization/stripe",
    data: { secret_key: stripeSecretKey },
    secretKey: autumnSecretKey
  });
}

// source/core/auth.ts
async function getOTP(otp) {
  const response = await internalRequest({
    method: "GET",
    path: `/dev/otp/${otp}`
  });
  return response;
}

// source/commands/auth.ts
var passwordTheme = {
  style: {
    answer: (text) => {
      return chalk8.magenta("*".repeat(text.length));
    }
  }
};
var inputTheme = {
  style: {
    answer: (text) => {
      return chalk8.magenta(text);
    }
  }
};
async function AuthCommand() {
  if (readFromEnv({ bypass: true })) {
    let shouldReauth = await confirm({
      message: "You are already authenticated. Would you like to re-authenticate?",
      theme: inputTheme
    });
    if (!shouldReauth) return;
  }
  open(`${FRONTEND_URL}/dev/cli`);
  const otp = await input({
    message: "Enter OTP:",
    theme: inputTheme
  });
  const keyInfo = await getOTP(otp);
  if (!keyInfo.stripe_connected) {
    let connectStripe = await confirm({
      message: "It seems like your organization doesn't have any Stripe keys connected. Would you like to connect your Stripe test secret key now?",
      theme: inputTheme
    });
    if (connectStripe) {
      let stripeTestKey = await password({
        message: "Enter Stripe Test Secret Key:",
        mask: "*",
        theme: passwordTheme
      });
      await updateCLIStripeKeys({
        stripeSecretKey: stripeTestKey,
        autumnSecretKey: keyInfo.sandboxKey
      });
      console.log(
        chalk8.green(
          "Stripe test secret key has been saved to your .env file. To connect your Stripe live secret key, please visit the Autumn dashboard here: https://app.useautumn.com/dev?tab=stripe"
        )
      );
    } else {
      console.log(
        chalk8.yellow(
          "Okay, no worries. Go to the Autumn dashboard when you're ready!"
        )
      );
    }
  }
  await storeToEnv(keyInfo.prodKey, keyInfo.sandboxKey);
  console.log(
    chalk8.green(
      "Success! Sandbox and production keys have been saved to your .env file.\n`atmn` uses the AUTUMN_SECRET_KEY to authenticate with the Autumn API."
    )
  );
}
async function getProducts(ids) {
  return await Promise.all(
    ids.map(
      (id) => externalRequest({
        method: "GET",
        path: `/products/${id}`
      })
    )
  );
}
async function getAllProducts(params) {
  const { list: products } = await externalRequest({
    method: "GET",
    path: `/products`,
    queryParams: { include_archived: params?.archived ? true : false }
  });
  return [...products];
}
async function getFeatures(params) {
  const { list } = await externalRequest({
    method: "GET",
    path: "/features",
    queryParams: { include_archived: params?.includeArchived ? true : false }
  });
  return list.map((feature) => feature);
}
var MAX_RECURSION_LIMIT = 500;
async function getCustomers(limit = 100, offset = 0) {
  const { list, total } = await externalRequest({
    method: "GET",
    path: `/customers?limit=${limit}&offset=${offset}`
  });
  const customers = list.map(
    (customer) => ({
      id: customer.id,
      text: customer.name || customer.email || customer.id
    })
  );
  if (offset + limit < total && offset < MAX_RECURSION_LIMIT) {
    const remainingCustomers = await getCustomers(limit, offset + limit);
    return [...customers, ...remainingCustomers];
  } else if (offset >= MAX_RECURSION_LIMIT) {
    console.log(
      chalk8.red(
        `Reached maximum recursion limit of ${MAX_RECURSION_LIMIT} customers. Exiting.`
      )
    );
    process.exit(1);
  }
  return customers;
}

// source/core/builders/freeTrialBuilder.ts
function freeTrialBuilder({ freeTrial }) {
  return `free_trial: {
		duration: '${freeTrial.duration}',
		length: ${freeTrial.length},
		unique_fingerprint: ${freeTrial.unique_fingerprint},
		card_required: ${freeTrial.card_required},
	},`;
}

// source/core/builders/productBuilder.ts
var ItemBuilders = {
  priced_feature: pricedFeatureItemBuilder,
  feature: featureItemBuilder,
  price: priceItemBuilder
};
function importBuilder() {
  return `
import {
	feature,
	product,
	featureItem,
	pricedFeatureItem,
	priceItem,
} from 'atmn';
    `;
}
function productBuilder({
  product,
  features
}) {
  const snippet = `
export const ${idToVar({ id: product.id, prefix: "product" })} = product({
    id: '${product.id}',
    name: '${product.name}',
    items: [${product.items.map(
    (item) => `${ItemBuilders[item.type]({
      item,
      features
    })}`
  ).join("           ")}     ],
	${product.free_trial ? `${freeTrialBuilder({ freeTrial: product.free_trial })}` : ""}
})
`;
  return snippet;
}
var getFeatureIdStr = ({
  featureId,
  features
}) => {
  if (nullish(featureId)) return "";
  let feature = features.find((f) => f.id === featureId);
  if (feature?.archived) return `"${featureId}"`;
  return `${idToVar({ id: featureId, prefix: "feature" })}.id`;
};
var getItemFieldPrefix = () => {
  return `
            `;
};
var getResetUsageStr = ({
  item,
  features
}) => {
  if (!item.feature_id) return "";
  const feature = features.find((f) => f.id === item.feature_id);
  if (feature.type === "boolean" || feature.type === "credit_system") return "";
  const defaultResetUsage = feature.type === "single_use" ? true : false;
  if (notNullish(item.reset_usage_when_enabled) && item.reset_usage_when_enabled !== defaultResetUsage) {
    return `${getItemFieldPrefix()}reset_usage_when_enabled: ${item.reset_usage_when_enabled},`;
  }
  return "";
};
var getIntervalStr = ({ item }) => {
  if (item.interval == null) return ``;
  return `${getItemFieldPrefix()}interval: '${item.interval}',`;
};
var getEntityFeatureIdStr = ({
  item,
  features
}) => {
  if (nullish(item.entity_feature_id)) return "";
  const featureIdStr = getFeatureIdStr({
    featureId: item.entity_feature_id,
    features
  });
  return `${getItemFieldPrefix()}entity_feature_id: ${featureIdStr},`;
};
var getPriceStr = ({ item }) => {
  if (item.tiers) {
    return `
		tiers: [
			${item.tiers.map(
      (tier) => `{ to: ${tier.to == "inf" ? "'inf'" : tier.to}, amount: ${tier.amount} }`
    ).join(",\n			")}
		],`;
  }
  if (item.price == null) return "";
  return `price: ${item.price},`;
};
function pricedFeatureItemBuilder({
  item,
  features
}) {
  const intervalStr = getIntervalStr({ item });
  const entityFeatureIdStr = getEntityFeatureIdStr({ item, features });
  const resetUsageStr = getResetUsageStr({ item, features });
  const priceStr = getPriceStr({ item });
  const featureIdStr = getFeatureIdStr({ featureId: item.feature_id, features });
  const snippet = `
        pricedFeatureItem({
            feature_id: ${featureIdStr},
            ${priceStr}${intervalStr}
            included_usage: ${item.included_usage == "inf" ? `"inf"` : item.included_usage},
            billing_units: ${item.billing_units},
            usage_model: '${item.usage_model}',${resetUsageStr}${entityFeatureIdStr}
        }),
`;
  return snippet;
}
function featureItemBuilder({
  item,
  features
}) {
  const featureIdStr = getFeatureIdStr({ featureId: item.feature_id, features });
  const entityFeatureIdStr = getEntityFeatureIdStr({ item, features });
  const intervalStr = getIntervalStr({ item });
  const resetUsageStr = getResetUsageStr({ item, features });
  const snippet = `
        featureItem({
            feature_id: ${featureIdStr},
            included_usage: ${item.included_usage == "inf" ? `"inf"` : item.included_usage},${intervalStr}${resetUsageStr}${entityFeatureIdStr}
        }),
`;
  return snippet;
}
function priceItemBuilder({ item }) {
  const intervalStr = getIntervalStr({ item });
  const snippet = `
        priceItem({
            price: ${item.price},${intervalStr}
        }),
`;
  return snippet;
}

// source/core/builders/featureBuilder.ts
var creditSchemaBuilder = (feature) => {
  if (feature.type == "credit_system") {
    let creditSchema = feature.credit_schema || [];
    return `
    credit_schema: [
        ${creditSchema.map(
      (credit) => `{
            metered_feature_id: '${credit.metered_feature_id}',
            credit_cost: ${credit.credit_cost},
        }`
    ).join(",\n        ")}
    ]`;
  }
  return "";
};
function featureBuilder(feature) {
  const snippet = `
export const ${idToVar({ id: feature.id, prefix: "feature" })} = feature({
    id: '${feature.id}',
    name: '${feature.name}',
    type: '${feature.type}',${creditSchemaBuilder(feature)}
})`;
  return snippet;
}
var ProductItemIntervalEnum = z.enum(
  ["minute", "hour", "day", "week", "month", "quarter", "semi_annual", "year"],
  {
    message: "Interval must be 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'semi_annual', or 'year'"
  }
);
var UsageModelEnum = z.enum(["prepaid", "pay_per_use"], {
  message: "Usage model must be 'prepaid' or 'pay_per_use'"
});
var ProductItemSchema = z.object({
  type: z.enum(["feature", "priced_feature"], {
    message: "Type must be 'feature' or 'priced_feature'"
  }).nullish(),
  feature_id: z.string({
    message: "Feature ID must be a string"
  }).nullish(),
  included_usage: z.union([z.number(), z.literal("inf")], {
    message: 'Included usage must be a number or "inf"'
  }).nullish(),
  interval: ProductItemIntervalEnum.nullish(),
  usage_model: UsageModelEnum.nullish(),
  price: z.number({
    message: "Price must be a valid number"
  }).nullish(),
  tiers: z.array(
    z.object({
      amount: z.number({
        message: "Tier amount must be a valid number"
      }),
      to: z.union([z.number(), z.literal("inf")], {
        message: 'Tier "to" must be a number or "inf"'
      })
    })
  ).nullish(),
  billing_units: z.number({
    message: "Billing units must be a valid number"
  }).nullish(),
  reset_usage_when_enabled: z.boolean({
    message: "Reset usage when enabled must be true or false"
  }).optional(),
  entity_feature_id: z.string({
    message: "Entity feature ID must be a string"
  }).optional()
});
z.object({
  feature_id: z.string({
    message: "Feature ID is required and must be a string"
  }),
  included_usage: z.number({
    message: "Included usage must be a valid number"
  }).nullish(),
  interval: ProductItemIntervalEnum.nullish()
});
z.object({
  price: z.number({
    message: "Price must be a valid number"
  }).gt(0, "Price must be greater than 0"),
  interval: ProductItemIntervalEnum.nullish()
});

// source/compose/models/composeModels.ts
var FreeTrialSchema = z.object({
  duration: z.enum(["day", "month", "year"], {
    message: "Duration must be 'day', 'month', or 'year'"
  }),
  length: z.number({
    message: "Length must be a valid number"
  }),
  unique_fingerprint: z.boolean({
    message: "Unique fingerprint must be true or false"
  }),
  card_required: z.boolean({
    message: "Card required must be true or false"
  })
});
var ProductSchema = z.object({
  id: z.string().min(1, "Product ID is required and cannot be empty"),
  name: z.string().min(1, "Product name is required and cannot be empty"),
  is_add_on: z.boolean().prefault(false).optional(),
  is_default: z.boolean().prefault(false).optional(),
  items: z.array(ProductItemSchema, {
    message: "Items must be an array of product items"
  }),
  free_trial: FreeTrialSchema.optional(),
  archived: z.boolean().optional()
});
var FeatureSchema = z.object({
  id: z.string().min(1, "Feature ID is required and cannot be empty"),
  name: z.string().optional(),
  type: z.enum(["boolean", "single_use", "continuous_use", "credit_system"], {
    message: "Type must be 'boolean', 'single_use', 'continuous_use', or 'credit_system'"
  }),
  credit_schema: z.array(
    z.object({
      metered_feature_id: z.string({
        message: "Metered feature ID must be a string"
      }),
      credit_cost: z.number({
        message: "Credit cost must be a valid number"
      })
    })
  ).optional(),
  archived: z.boolean().optional()
});

// source/core/config.ts
function checkAtmnInstalled() {
  try {
    const packageJsonPath = path.join(process.cwd(), "package.json");
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf-8"));
      return !!(packageJson.dependencies?.atmn || packageJson.devDependencies?.atmn);
    }
    execSync(`node -e "require.resolve('atmn')"`, { stdio: "ignore" });
    return true;
  } catch {
    return false;
  }
}
async function installAtmn() {
  const shouldInstall = await confirm({
    message: "The atmn package is not installed. Would you like to install it now?",
    default: true
  });
  if (!shouldInstall) {
    console.log(
      chalk8.yellow(
        "Skipping installation. You can install atmn manually with your preferred package manager."
      )
    );
    return false;
  }
  const packageManager = await select({
    message: "Which package manager would you like to use?",
    choices: [
      { name: "npm", value: "npm" },
      { name: "pnpm", value: "pnpm" },
      { name: "bun", value: "bun" }
    ],
    default: "npm"
  });
  try {
    console.log(chalk8.blue(`Installing atmn with ${packageManager}...`));
    const installCommand = packageManager === "npm" ? "npm install atmn" : packageManager === "pnpm" ? "pnpm add atmn" : "bun add atmn";
    execSync(installCommand, { stdio: "inherit" });
    console.log(chalk8.green("atmn installed successfully!"));
    return true;
  } catch (error) {
    console.error(chalk8.red("Failed to install atmn:"), error);
    return false;
  }
}
function isProduct(value) {
  try {
    ProductSchema.parse(value);
    return true;
  } catch (error) {
    return false;
  }
}
function isFeature(value) {
  try {
    FeatureSchema.parse(value);
    return true;
  } catch {
    return false;
  }
}
function detectObjectType(value) {
  if (value && typeof value === "object") {
    if (value.items && Array.isArray(value.items)) {
      return "product";
    }
    if (value.type) {
      return "feature";
    }
  }
  return "unknown";
}
function getValidationError(schema, value) {
  try {
    schema.parse(value);
    return "";
  } catch (error) {
    if (error.name === "ZodError" && error.issues) {
      const formattedErrors = error.issues.map((issue) => {
        const path2 = issue.path.length > 0 ? `${issue.path.join(".")}` : "root";
        return `  \u2022 ${path2}: ${issue.message}`;
      });
      return `
${formattedErrors.join("\n")}`;
    }
    if (error.errors && Array.isArray(error.errors)) {
      const formattedErrors = error.errors.map((e) => {
        const path2 = e.path && e.path.length > 0 ? `${e.path.join(".")}` : "root";
        return `  \u2022 ${path2}: ${e.message}`;
      });
      return `
${formattedErrors.join("\n")}`;
    }
    return error.message || "Unknown validation error";
  }
}
async function loadAutumnConfigFile() {
  const configPath = path.join(process.cwd(), "autumn.config.ts");
  const absolutePath = resolve(configPath);
  const fileUrl = pathToFileURL(absolutePath).href;
  if (!checkAtmnInstalled()) {
    const installed = await installAtmn();
    if (!installed) {
      throw new Error(
        "atmn package is required but not installed. Please install it manually."
      );
    }
  }
  const jiti = createJiti(import.meta.url);
  const mod = await jiti.import(fileUrl);
  const products = [];
  const features = [];
  const defaultExport = mod.default;
  if (defaultExport && defaultExport.products && defaultExport.features) {
    if (Array.isArray(defaultExport.products)) {
      products.push(...defaultExport.products);
    }
    if (Array.isArray(defaultExport.features)) {
      features.push(...defaultExport.features);
    }
  } else {
    for (const [key, value] of Object.entries(mod)) {
      if (key === "default") continue;
      if (isProduct(value)) {
        products.push(value);
      } else if (isFeature(value)) {
        features.push(value);
      } else {
        const detectedType = detectObjectType(value);
        if (detectedType === "product") {
          const validationError = getValidationError(ProductSchema, value);
          console.error("\n" + chalk8.red("\u274C Invalid product configuration"));
          console.error(chalk8.yellow(`Product: "${key}"`));
          console.error(chalk8.red("Validation errors:") + validationError);
          process.exit(1);
        } else if (detectedType === "feature") {
          const validationError = getValidationError(FeatureSchema, value);
          console.error("\n" + chalk8.red("\u274C Invalid feature configuration"));
          console.error(chalk8.yellow(`Feature: "${key}"`));
          console.error(chalk8.red("Validation errors:") + validationError);
          process.exit(1);
        } else {
          console.error("\n" + chalk8.red("\u274C Invalid object configuration"));
          console.error(chalk8.yellow(`Object: "${key}"`));
          console.error(
            chalk8.red("Error:") + " Object must be either a product (with 'items' field) or feature (with 'type' field)"
          );
          process.exit(1);
        }
      }
    }
  }
  const secretKey = readFromEnv();
  if (secretKey?.includes("live")) {
    console.log(chalk8.magentaBright("Running in production environment..."));
  } else {
    console.log(chalk8.yellow("Running in sandbox environment..."));
  }
  return {
    products,
    features,
    env: secretKey?.includes("live") ? "prod" : "sandbox"
  };
}
function writeConfig(config) {
  const configPath = path.join(process.cwd(), "autumn.config.ts");
  fs.writeFileSync(configPath, config);
}

// source/commands/pull.ts
async function Pull(options) {
  console.log(chalk8.green("Pulling products and features from Autumn..."));
  const products = await getAllProducts({ archived: options?.archived ?? false });
  const features = await getFeatures({ includeArchived: true });
  const productSnippets = products.map(
    (product) => productBuilder({ product, features })
  );
  const featureSnippets = features.filter((feature) => !feature.archived).map((feature) => featureBuilder(feature));
  const autumnConfig = `
${importBuilder()}

// Features${featureSnippets.join("\n")}

// Products${productSnippets.join("\n")}
	`;
  const formattedConfig = await prettier.format(autumnConfig, {
    parser: "typescript",
    useTabs: true,
    singleQuote: false
  });
  writeConfig(formattedConfig);
  console.log(chalk8.green("Success! Config has been updated."));
}

// source/commands/init.ts
async function Init() {
  let apiKey = readFromEnv();
  if (apiKey) {
    console.log(chalk8.green("API key found. Pulling latest config..."));
    await Pull();
    console.log(
      chalk8.green("Project initialized and config pulled successfully!")
    );
    return;
  }
  console.log(chalk8.yellow("No API key found. Running authentication..."));
  await AuthCommand();
  apiKey = readFromEnv();
  if (apiKey) {
    await Pull();
    console.log(
      chalk8.green(
        "Project initialized! You are now authenticated and config has been pulled."
      )
    );
  } else {
    console.log(
      chalk8.red(
        "Authentication did not yield an API key. Please check your setup."
      )
    );
  }
}

// source/core/nuke.ts
async function nukeCustomers(customers) {
  const s = initSpinner("Deleting customers");
  const total = customers.length;
  if (total === 0) {
    s.success("Customers deleted successfully!");
    return;
  }
  const concurrency = Math.max(
    1,
    Math.min(total, Number(process.env["ATM_DELETE_CONCURRENCY"] ?? 5) || 5)
  );
  let completed = 0;
  const updateSpinner = () => {
    s.text = `Deleting customers: ${completed} / ${total}`;
  };
  updateSpinner();
  for (let i = 0; i < total; i += concurrency) {
    const batch = customers.slice(i, i + concurrency);
    await Promise.all(
      batch.map(async (customer) => {
        try {
          await deleteCustomer(customer.id);
        } finally {
          completed++;
          updateSpinner();
        }
      })
    );
  }
  s.success("Customers deleted successfully!");
}
async function deleteCustomer(id) {
  await externalRequest({
    method: "DELETE",
    path: `/customers/${id}`
  });
}
async function nukeProducts(ids) {
  const s = initSpinner("Deleting products");
  for (const id of ids) {
    s.text = `Deleting product [${id}] ${ids.indexOf(id) + 1} / ${ids.length}`;
    await deleteProduct({ id, allVersions: true });
  }
  s.success("Products deleted successfully!");
}
async function nukeFeatures(ids) {
  const s = initSpinner("Deleting features");
  for (const id of ids) {
    s.text = `Deleting feature [${id}] ${ids.indexOf(id) + 1} / ${ids.length}`;
    await deleteFeature({ id });
  }
  s.success("Features deleted successfully!");
}

// source/core/requests/orgRequests.ts
var getOrg = async () => {
  const response = await externalRequest({
    method: "GET",
    path: "/organization"
  });
  return response;
};

// source/commands/nuke.ts
async function promptAndConfirmNuke(orgName) {
  console.log("\n" + chalk8.bgRed.white.bold("  DANGER: SANDBOX NUKE  "));
  console.log(
    chalk8.red(
      `This is irreversible. You are about to permanently delete all data from the organization ` + chalk8.redBright.bold(orgName) + `

Items to be deleted:
  \u2022 ` + chalk8.yellowBright("customers") + `
  \u2022 ` + chalk8.yellowBright("features") + `
  \u2022 ` + chalk8.yellowBright("products") + `
`
    )
  );
  const shouldProceed = await confirm({
    message: `Confirm to continue. This will delete ${chalk8.redBright.bold("all")} your ${chalk8.redBright.bold("products")}, ${chalk8.redBright.bold("features")} and ${chalk8.redBright.bold("customers")} from your sandbox environment. You will confirm twice.`,
    default: false
  });
  if (!shouldProceed) {
    console.log(chalk8.red("Aborting..."));
    process.exit(1);
  }
  const finalConfirm = await confirm({
    message: "Final confirmation: Are you absolutely sure? This action is irreversible.",
    default: false
  });
  if (!finalConfirm) {
    console.log(chalk8.red("Aborting..."));
    process.exit(1);
  }
  const backupConfirm = await confirm({
    message: `Would you like to backup your ${chalk8.magentaBright.bold("autumn.config.ts")} file before proceeding? (Recommended)`,
    default: true
  });
  return backupConfirm;
}
async function Nuke() {
  const apiKey = readFromEnv();
  const isSandbox = await isSandboxKey(apiKey);
  if (isSandbox) {
    const org = await getOrg();
    const backupConfirm = await promptAndConfirmNuke(org.name);
    if (backupConfirm) {
      fs.copyFileSync("autumn.config.ts", "autumn.config.ts.backup");
      console.log(chalk8.green("Backup created successfully!"));
    }
    console.log(chalk8.red("Nuking sandbox..."));
    const s = initSpinner(
      `Preparing ${chalk8.yellowBright("customers")}, ${chalk8.yellowBright("features")} and ${chalk8.yellowBright("products")} for deletion...`
    );
    const products = await getAllProducts({ archived: true });
    const features = await getFeatures();
    const customers = await getCustomers();
    s.success(
      `Loaded all ${chalk8.yellowBright("customers")}, ${chalk8.yellowBright("features")} and ${chalk8.yellowBright("products")} for deletion`
    );
    features.sort((a, b) => {
      if (a.type === "credit_system") {
        return -1;
      }
      return 1;
    });
    try {
      await nukeCustomers(customers);
      await nukeProducts(products.map((product) => product.id));
      await nukeFeatures(features.map((feature) => feature.id));
    } catch (e) {
      console.error(chalk8.red("Failed to nuke sandbox:"));
      console.error(e);
      process.exit(1);
    }
    console.log(chalk8.green("Sandbox nuked successfully!"));
  } else {
    console.log(chalk8.red`You can't nuke a prod environment!`);
    process.exit(1);
  }
}

// source/core/push.ts
async function checkForDeletables(currentFeatures, currentProducts) {
  const features = await getFeatures({ includeArchived: true });
  const featureIds = features.map((feature) => feature.id);
  const currentFeatureIds = currentFeatures.map((feature) => feature.id);
  const featuresToDelete = featureIds.filter(
    (featureId) => !currentFeatureIds.includes(featureId) && !features.some(
      (feature) => feature.id === featureId && feature.archived
    )
  );
  const products = await getAllProducts();
  const productIds = products.map((product) => product.id);
  const currentProductIds = currentProducts.map(
    (product) => product.id
  );
  const productsToDelete = productIds.filter(
    (productId) => !currentProductIds.includes(productId)
  );
  return {
    allFeatures: features,
    curFeatures: features.filter((feature) => !feature.archived),
    curProducts: products,
    featuresToDelete,
    productsToDelete
  };
}
var isDuplicate = (error) => {
  return error.response && error.response.data && (error.response.data.code === "duplicate_feature_id" || error.response.data.code === "product_already_exists");
};
async function upsertFeature(feature, s) {
  try {
    const response = await externalRequest({
      method: "POST",
      path: `/features`,
      data: feature,
      throwOnError: true
    });
    return response.data;
  } catch (error) {
    if (isDuplicate(error)) {
      const response = await externalRequest({
        method: "POST",
        path: `/features/${feature.id}`,
        data: feature
      });
      return response.data;
    }
    console.error(
      `
Failed to push feature ${feature.id}: ${error.response?.data?.message || "Unknown error"}`
    );
    process.exit(1);
  } finally {
    s.text = `Pushed feature [${feature.id}]`;
  }
}
async function checkProductForConfirmation({
  curProducts,
  product
}) {
  const curProduct = curProducts.find((p) => p.id === product.id);
  if (!curProduct) {
    return {
      id: product.id,
      will_version: false
    };
  }
  const res1 = await externalRequest({
    method: "GET",
    path: `/products/${product.id}/has_customers`,
    data: product
  });
  return {
    id: product.id,
    will_version: res1.will_version,
    archived: res1.archived
  };
}
async function upsertProduct({
  curProducts,
  product,
  spinner,
  shouldUpdate = true
}) {
  if (!shouldUpdate) {
    spinner.text = `Skipping update to product ${product.id}`;
    return {
      id: product.id,
      action: "skipped"
    };
  }
  const curProduct = curProducts.find((p) => p.id === product.id);
  if (!curProduct) {
    await externalRequest({
      method: "POST",
      path: `/products`,
      data: product
    });
    spinner.text = `Created product [${product.id}]`;
    return {
      id: product.id,
      action: "create"
    };
  } else {
    await externalRequest({
      method: "POST",
      path: `/products/${product.id}`,
      data: product
    });
    spinner.text = `Updated product [${product.id}]`;
    return {
      id: product.id,
      action: "updated"
    };
  }
}

// source/core/requests/featureRequests.ts
var updateFeature = async ({
  id,
  update
}) => {
  return await externalRequest({
    method: "POST",
    path: `/features/${id}`,
    data: update
  });
};
var checkFeatureDeletionData = async ({
  featureId
}) => {
  const res = await externalRequest({
    method: "GET",
    path: `/features/${featureId}/deletion_info`
  });
  return res;
};

// source/core/requests/prodRequests.ts
var getProductDeleteInfo = async ({
  productId
}) => {
  const response = await externalRequest({
    method: "GET",
    path: `/products/${productId}/deletion_info`
  });
  return response;
};
var updateProduct = async ({
  productId,
  update
}) => {
  const response = await externalRequest({
    method: "POST",
    path: `/products/${productId}`,
    data: update
  });
  return response;
};

// source/commands/push.ts
var createSpinner = ({ message }) => {
  const spinner = yoctoSpinner({
    text: message ?? ""
  });
  spinner.start();
  return spinner;
};
var gatherProductDeletionDecisions = async ({
  productsToDelete,
  yes
}) => {
  const productDeletionDecisions = /* @__PURE__ */ new Map();
  const batchCheckProducts = [];
  for (const productId of productsToDelete) {
    batchCheckProducts.push(getProductDeleteInfo({ productId }));
  }
  const checkProductResults = await Promise.all(batchCheckProducts);
  for (let i = 0; i < productsToDelete.length; i++) {
    const productId = productsToDelete[i];
    const result = checkProductResults[i];
    if (!productId) continue;
    const product = (await getProducts([productId])).find(
      (x) => x.id === productId
    );
    if (result && result.totalCount > 0) {
      const otherCustomersText = result.totalCount > 1 ? ` and ${result.totalCount - 1} other customer(s)` : "";
      const customerNameText = result.customerName || "Unknown Customer";
      if (product?.archived) {
        productDeletionDecisions.set(productId, "skip");
      } else {
        const shouldArchive = yes || await confirm({
          message: `Product ${productId} has customer ${customerNameText}${otherCustomersText}. As such, you cannot delete it. Would you like to archive the product instead?`
        });
        productDeletionDecisions.set(
          productId,
          shouldArchive ? "archive" : "skip"
        );
      }
    } else {
      productDeletionDecisions.set(productId, "delete");
    }
  }
  return productDeletionDecisions;
};
var handleProductDeletion = async ({
  productsToDelete,
  yes
}) => {
  const productDeletionDecisions = await gatherProductDeletionDecisions({
    productsToDelete,
    yes
  });
  for (const productId of productsToDelete) {
    const decision = productDeletionDecisions.get(productId);
    if (decision === "delete") {
      const shouldDelete = yes || await confirm({
        message: `Delete product [${productId}]?`
      });
      if (shouldDelete) {
        const s = createSpinner({ message: `Deleting product [${productId}]` });
        await deleteProduct({ id: productId });
        s.success(`Product [${productId}] deleted successfully!`);
      }
    } else if (decision === "archive") {
      const s = createSpinner({ message: `Archiving product [${productId}]` });
      await updateProduct({ productId, update: { archived: true } });
      s.success(`Product [${productId}] archived successfully!`);
    }
  }
};
var pushFeatures = async ({
  features,
  allFeatures,
  yes
}) => {
  for (const feature of features) {
    const isArchived = allFeatures.find(
      (f) => f.id === feature.id
    )?.archived;
    if (isArchived) {
      const shouldUnarchive = yes || await confirm({
        message: `Feature ${feature.id} is currently archived. Would you like to un-archive it before pushing?`
      });
      if (shouldUnarchive) {
        const s2 = createSpinner({
          message: `Un-archiving feature [${feature.id}]`
        });
        await updateFeature({ id: feature.id, update: { archived: false } });
        s2.success(`Feature [${feature.id}] un-archived successfully!`);
      }
    }
  }
  const batchFeatures = [];
  const s = initSpinner(`Pushing features`);
  for (const feature of features) {
    batchFeatures.push(upsertFeature(feature, s));
  }
  await Promise.all(batchFeatures);
  s.success(`Features pushed successfully!`);
  console.log(chalk8.dim("\nFeatures pushed:"));
  features.forEach((feature) => {
    console.log(chalk8.cyan(`  \u2022 ${feature.id}`));
  });
  console.log();
};
var gatherProductDecisions = async ({
  products,
  curProducts,
  yes
}) => {
  const productDecisions = /* @__PURE__ */ new Map();
  const batchCheckProducts = [];
  for (const product of products) {
    batchCheckProducts.push(
      checkProductForConfirmation({
        curProducts,
        product
      })
    );
  }
  const checkProductResults = await Promise.all(batchCheckProducts);
  for (const result of checkProductResults) {
    if (result.archived) {
      const shouldUnarchive = yes || await confirm({
        message: `Product ${result.id} is currently archived. Would you like to un-archive it before pushing?`
      });
      if (shouldUnarchive) {
        const s = createSpinner({
          message: `Un-archiving product [${result.id}]`
        });
        await updateProduct({
          productId: result.id,
          update: { archived: false }
        });
        s.success(`Product [${result.id}] un-archived successfully!`);
        productDecisions.set(result.id, true);
      } else {
        productDecisions.set(result.id, false);
      }
    }
    if (result.will_version) {
      const shouldUpdate = yes || await confirm({
        message: `Product ${result.id} has customers on it and updating it will create a new version.
Are you sure you'd like to continue? `
      });
      productDecisions.set(result.id, shouldUpdate);
    } else {
      productDecisions.set(result.id, true);
    }
  }
  return productDecisions;
};
var pushProducts = async ({
  products,
  curProducts,
  productDecisions,
  yes
}) => {
  const s2 = initSpinner(`Pushing products`);
  const batchProducts = [];
  for (const product of products) {
    const shouldUpdate = productDecisions.get(product.id);
    batchProducts.push(
      upsertProduct({ curProducts, product, spinner: s2, shouldUpdate })
    );
  }
  const prodResults = await Promise.all(batchProducts);
  s2.success(`Products pushed successfully!`);
  console.log(chalk8.dim("\nProducts pushed:"));
  prodResults.forEach((result) => {
    const action = result.action;
    console.log(
      chalk8.cyan(
        `  \u2022 ${result.id} ${action === "skipped" ? `(${action})` : ""}`
      )
    );
  });
  console.log();
  return prodResults;
};
var gatherFeatureDeletionDecisions = async ({
  featuresToDelete,
  currentFeatures,
  yes
}) => {
  const featureDeletionDecisions = /* @__PURE__ */ new Map();
  const batchCheckFeatures = [];
  for (const featureId of featuresToDelete) {
    batchCheckFeatures.push(checkFeatureDeletionData({ featureId }));
  }
  const checkFeatureResults = await Promise.all(batchCheckFeatures);
  for (let i = 0; i < featuresToDelete.length; i++) {
    const featureId = featuresToDelete[i];
    const result = checkFeatureResults[i];
    if (!featureId) continue;
    const referencingCreditSystems = currentFeatures.filter(
      (f) => f.type === "credit_system" && f.credit_schema?.some((cs) => cs.metered_feature_id === featureId)
    );
    if (referencingCreditSystems.length > 0) {
      const firstCreditSystem = referencingCreditSystems[0].id;
      const creditSystemText = referencingCreditSystems.length === 1 ? `the "${firstCreditSystem}" credit system` : referencingCreditSystems.length === 2 ? `"${firstCreditSystem}" and one other credit system` : `"${firstCreditSystem}" and ${referencingCreditSystems.length - 1} other credit systems`;
      const shouldArchive = yes || await confirm({
        message: `Feature ${featureId} is used by ${creditSystemText}. As such, you cannot delete it. Would you like to archive the feature instead?`
      });
      featureDeletionDecisions.set(
        featureId,
        shouldArchive ? "archive" : "skip"
      );
    } else if (result && result.totalCount > 0) {
      const otherProductsText = result.totalCount > 1 ? ` and ${result.totalCount - 1} other products` : "";
      const productNameText = result.productName || "Unknown Product";
      const shouldArchive = yes || await confirm({
        message: `Feature ${featureId} is being used by product ${productNameText}${otherProductsText}. As such, you cannot delete it. Would you like to archive the feature instead?`
      });
      featureDeletionDecisions.set(
        featureId,
        shouldArchive ? "archive" : "skip"
      );
    } else {
      featureDeletionDecisions.set(featureId, "delete");
    }
  }
  return featureDeletionDecisions;
};
var handleFeatureDeletion = async ({
  featuresToDelete,
  allFeatures,
  currentFeatures,
  yes
}) => {
  const featureDeletionDecisions = await gatherFeatureDeletionDecisions({
    featuresToDelete,
    currentFeatures,
    yes
  });
  const sortedFeaturesToDelete = [...featuresToDelete].sort((a, b) => {
    const featureA = allFeatures.find((f) => f.id === a);
    const featureB = allFeatures.find((f) => f.id === b);
    if (featureA?.type === "credit_system" && featureB?.type !== "credit_system") {
      return -1;
    }
    if (featureA?.type !== "credit_system" && featureB?.type === "credit_system") {
      return 1;
    }
    return 0;
  });
  for (const featureId of sortedFeaturesToDelete) {
    const decision = featureDeletionDecisions.get(featureId);
    if (decision === "delete") {
      const shouldDelete = yes || await confirm({
        message: `Delete feature [${featureId}]?`
      });
      if (shouldDelete) {
        const s = createSpinner({ message: `Deleting feature [${featureId}]` });
        await deleteFeature({ id: featureId });
        s.success(`Feature [${featureId}] deleted successfully!`);
      }
    } else if (decision === "archive") {
      const s = createSpinner({ message: `Archiving feature [${featureId}]` });
      await updateFeature({ id: featureId, update: { archived: true } });
      s.success(`Feature [${featureId}] archived successfully!`);
    }
  }
};
var showSuccessMessage = ({ env, prod }) => {
  console.log(
    chalk8.magentaBright(`Success! Changes have been pushed to ${env}.`)
  );
  if (prod) {
    console.log(
      chalk8.magentaBright(
        `You can view the products at ${FRONTEND_URL}/products`
      )
    );
  } else {
    console.log(
      chalk8.magentaBright(
        `You can view the products at ${FRONTEND_URL}/sandbox/products`
      )
    );
  }
};
async function Push({
  config,
  yes,
  prod
}) {
  const { features, products, env } = config;
  if (env === "prod") {
    const shouldProceed = yes || await confirm({
      message: "You are about to push products to your prod environment. Are you sure you want to proceed?",
      default: false
    });
    if (!shouldProceed) {
      console.log(chalk8.yellow("Aborting..."));
      process.exit(1);
    }
  }
  const { allFeatures, curProducts, featuresToDelete, productsToDelete } = await checkForDeletables(features, products);
  await handleProductDeletion({ productsToDelete, yes });
  await pushFeatures({ features, allFeatures, yes });
  const productDecisions = await gatherProductDecisions({
    products,
    curProducts,
    yes
  });
  await pushProducts({ products, curProducts, productDecisions, yes });
  await handleFeatureDeletion({ featuresToDelete, allFeatures, currentFeatures: features, yes });
  showSuccessMessage({ env, prod });
}

// source/cli.ts
var computedVersion = typeof VERSION !== "undefined" && VERSION ? VERSION : "dev";
program.version(computedVersion);
program.option("-p, --prod", "Push to production");
program.option("-l, --local", "Use local autumn environment");
program.command("env").description("Check the environment of your API key").action(async () => {
  const env = await isSandboxKey(readFromEnv() ?? "");
  console.log(chalk8.green(`Environment: ${env ? "Sandbox" : "Production"}`));
});
program.command("nuke").description("Permannently nuke your sandbox.").action(async () => {
  await Nuke();
});
program.command("push").description("Push changes to Autumn").option("-p, --prod", "Push to production").option("-y, --yes", "Confirm all deletions").action(async (options) => {
  const config = await loadAutumnConfigFile();
  await Push({ config, yes: options.yes, prod: options.prod });
});
program.command("pull").description("Pull changes from Autumn").option("-p, --prod", "Pull from production").action(async (options) => {
  await Pull({ archived: options.archived ?? false });
});
program.command("init").description("Initialize an Autumn project.").action(async () => {
  writeConfig(DEFAULT_CONFIG);
  await Init();
});
program.command("login").description("Authenticate with Autumn").option("-p, --prod", "Authenticate with production").action(async () => {
  await AuthCommand();
});
program.command("dashboard").description("Open the Autumn dashboard in your browser").action(() => {
  open(`${FRONTEND_URL}`);
});
program.command("version").alias("v").description("Show the version of Autumn").action(() => {
  console.log(computedVersion);
});
var originalEmit = process.emitWarning;
process.emitWarning = (warning, ...args) => {
  const msg = typeof warning === "string" ? warning : warning.message;
  if (msg.includes("url.parse()")) {
    return;
  }
  return originalEmit(warning, ...args);
};
program.parse();
