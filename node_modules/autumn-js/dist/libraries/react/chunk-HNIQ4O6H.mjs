"use client";

import {
  CheckFeatureResultSchema
} from "./chunk-QN2ALOVD.mjs";

// src/libraries/react/hooks/helpers/handleCheck.ts
var getCusFeature = ({
  customer,
  featureId,
  requiredBalance = 1
}) => {
  let cusFeature = customer.features[featureId];
  if (cusFeature && typeof cusFeature.balance === "number" && cusFeature.balance >= requiredBalance) {
    return {
      cusFeature,
      requiredBalance
    };
  }
  let creditSchema = Object.values(customer.features).find(
    (f) => f.credit_schema && f.credit_schema.some((c) => c.feature_id === featureId)
  );
  if (creditSchema) {
    let schemaItem = creditSchema.credit_schema?.find(
      (c) => c.feature_id === featureId
    );
    return {
      cusFeature: creditSchema,
      requiredBalance: schemaItem.credit_amount * requiredBalance
    };
  }
  return {
    cusFeature: customer.features[featureId],
    requiredBalance
  };
};
var getFeatureAllowed = ({
  cusFeature,
  requiredBalance
}) => {
  if (!cusFeature) return false;
  if (cusFeature.type == "static") return true;
  if (cusFeature.unlimited || cusFeature.overage_allowed) return true;
  if (cusFeature.usage_limit) {
    let extraUsage = (cusFeature.usage_limit || 0) - (cusFeature.included_usage || 0);
    return (cusFeature.balance || 0) + extraUsage >= requiredBalance;
  }
  return (cusFeature.balance || 0) >= requiredBalance;
};
var handleFeatureCheck = ({
  customer,
  isEntity,
  params
}) => {
  let { cusFeature, requiredBalance } = getCusFeature({
    customer,
    featureId: params.featureId,
    ...params.requiredBalance ? { requiredBalance: params.requiredBalance } : {}
  });
  let allowed = getFeatureAllowed({
    cusFeature,
    requiredBalance: requiredBalance ?? 1
  });
  let result = {
    allowed,
    feature_id: cusFeature?.id ?? params.featureId,
    customer_id: isEntity ? customer.customer_id : customer.id,
    required_balance: requiredBalance,
    ...cusFeature
  };
  if (isEntity) {
    result.entity_id = customer.id;
  }
  try {
    return CheckFeatureResultSchema.parse(result);
  } catch (error) {
    return result;
  }
};
var handleProductCheck = ({
  customer,
  isEntity,
  params
}) => {
  let product = customer.products.find((p) => p.id == params.productId);
  let allowed = product?.status === "active" || product?.status === "trialing";
  let result = {
    allowed,
    customer_id: isEntity ? customer.customer_id : customer.id,
    product_id: params.productId
  };
  if (product) {
    result.status = product.status;
  }
  if (isEntity) {
    result.entity_id = customer.id;
  }
  return result;
};
var openDialog = ({
  result,
  params,
  context
}) => {
  let open = result?.allowed === false && params.dialog && context;
  if (!open) return;
  const isInRenderCycle = (() => {
    const stack = new Error().stack || "";
    return stack.includes("renderWithHooks") || stack.includes("updateFunctionComponent") || stack.includes("beginWork") || stack.includes("performUnitOfWork") || stack.includes("workLoop") || stack.includes("Component.render") || stack.includes("FunctionComponent");
  })();
  if (isInRenderCycle) {
    context.paywallRef.current = {
      component: params.dialog,
      open: true,
      props: params
    };
  } else {
    context.paywallDialog.setComponent(params.dialog);
    context.paywallDialog.setProps(params);
    context.paywallDialog.setOpen(true);
  }
};
var handleCheck = ({
  customer,
  isEntity,
  params,
  context
}) => {
  if (!customer) {
    return {
      data: {
        allowed: false,
        feature_id: "",
        customer_id: "",
        required_balance: 0
      },
      error: null
    };
  }
  if (!params.featureId && !params.productId) {
    throw new Error("allowed() requires either featureId or productId");
  }
  let result;
  if (params.featureId)
    result = handleFeatureCheck({ customer, params, isEntity });
  if (params.productId)
    result = handleProductCheck({ customer, params, isEntity });
  return {
    data: result,
    error: null
  };
};

export {
  openDialog,
  handleCheck
};
