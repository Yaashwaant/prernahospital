"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/libraries/backend/routes/entityRoutes.ts
var entityRoutes_exports = {};
__export(entityRoutes_exports, {
  addEntityRoutes: () => addEntityRoutes
});
module.exports = __toCommonJS(entityRoutes_exports);
var import_rou3 = require("rou3");

// src/sdk/general/genMethods.ts
var handleCheckout = async ({
  instance,
  params
}) => {
  const finalParams = {
    ...params,
    success_url: params.success_url ?? instance.defaultReturnUrl
  };
  return instance.post("/checkout", finalParams);
};
var handleAttach = async ({
  instance,
  params
}) => {
  const finalParams = {
    ...params,
    success_url: params.success_url ?? instance.defaultReturnUrl
  };
  return instance.post("/attach", finalParams);
};
var handleSetupPayment = async ({
  instance,
  params
}) => {
  const finalParams = {
    ...params,
    success_url: params.success_url ?? instance.defaultReturnUrl
  };
  return instance.post("/setup_payment", finalParams);
};
var handleCancel = async ({
  instance,
  params
}) => {
  return instance.post("/cancel", params);
};
var handleTrack = async ({
  instance,
  params
}) => {
  return instance.post("/track", params);
};
var handleUsage = async ({
  instance,
  params
}) => {
  return instance.post("/usage", params);
};
var handleCheck = async ({
  instance,
  params
}) => {
  return instance.post("/check", params);
};
var handleQuery = async ({
  instance,
  params
}) => {
  return instance.post("/query", params);
};

// src/libraries/backend/constants.ts
var autumnApiUrl = "https://api.useautumn.com/v1";

// src/sdk/utils.ts
var import_query_string = __toESM(require("query-string"));
var staticWrapper = (callback, instance, args) => {
  if (!instance) {
    instance = new Autumn();
  }
  return callback({ instance, ...args });
};
var buildQueryString = (params) => {
  if (!params) return "";
  return import_query_string.default.stringify(params, {
    skipNull: true,
    skipEmptyString: true
  });
};
var buildPathWithQuery = (basePath, params) => {
  const query = buildQueryString(params);
  return query ? `${basePath}?${query}` : basePath;
};

// src/sdk/error.ts
var AutumnError = class _AutumnError extends Error {
  message;
  code;
  constructor(response) {
    super(response.message);
    this.message = response.message;
    this.code = response.code;
  }
  static fromError(error) {
    return new _AutumnError({
      message: error.message || "Unknown error",
      code: error.code || "unknown_error"
    });
  }
  toString() {
    return `${this.message} (code: ${this.code})`;
  }
  toJSON() {
    return {
      message: this.message,
      code: this.code
    };
  }
};

// src/sdk/customers/cusMethods.ts
var customerMethods = (instance) => {
  return {
    list: (params) => staticWrapper(listCustomers, instance, { params }),
    get: (id, params) => staticWrapper(getCustomer, instance, { id, params }),
    create: (params) => staticWrapper(createCustomer, instance, { params }),
    update: (id, params) => staticWrapper(updateCustomer, instance, { id, params }),
    delete: (id, params) => staticWrapper(deleteCustomer, instance, { id, params }),
    billingPortal: (id, params) => staticWrapper(billingPortal, instance, { id, params }),
    updateBalances: (id, params) => staticWrapper(updateBalances, instance, { id, params })
  };
};
var getExpandStr = (expand) => {
  if (!expand) {
    return "";
  }
  return `expand=${expand.join(",")}`;
};
var listCustomers = async ({
  instance,
  params
}) => {
  const path = buildPathWithQuery("/customers", params);
  return instance.get(path);
};
var getCustomer = async ({
  instance,
  id,
  params
}) => {
  if (!id) {
    return {
      data: null,
      error: new AutumnError({
        message: "Customer ID is required",
        code: "CUSTOMER_ID_REQUIRED"
      })
    };
  }
  return instance.get(`/customers/${id}?${getExpandStr(params?.expand)}`);
};
var createCustomer = async ({
  instance,
  params
}) => {
  return instance.post(`/customers?${getExpandStr(params?.expand)}`, params);
};
var updateCustomer = async ({
  instance,
  id,
  params
}) => {
  return instance.post(`/customers/${id}`, params);
};
var deleteCustomer = async ({
  instance,
  id,
  params
}) => {
  return instance.delete(`/customers/${id}${params?.delete_in_stripe ? "?delete_in_stripe=true" : ""}`);
};
var billingPortal = async ({
  instance,
  id,
  params
}) => {
  const finalParams = {
    ...params,
    return_url: params?.return_url ?? instance.defaultReturnUrl
  };
  return instance.post(`/customers/${id}/billing_portal`, finalParams);
};
var updateBalances = async ({
  instance,
  id,
  params
}) => {
  return instance.post(`/customers/${id}/balances`, {
    balances: Array.isArray(params) ? params : [params]
  });
};

// src/sdk/customers/entities/entMethods.ts
var entityMethods = (instance) => {
  return {
    get: (customer_id, entity_id, params) => staticWrapper(getEntity, instance, {
      customer_id,
      entity_id,
      params
    }),
    create: (customer_id, params) => staticWrapper(createEntity, instance, { customer_id, params }),
    transfer: (customer_id, params) => staticWrapper(transferProduct, instance, { customer_id, params }),
    delete: (customer_id, entity_id) => staticWrapper(deleteEntity, instance, { customer_id, entity_id })
  };
};
var getExpandStr2 = (expand) => {
  if (!expand) {
    return "";
  }
  return `expand=${expand.join(",")}`;
};
var getEntity = async ({
  instance,
  customer_id,
  entity_id,
  params
}) => {
  return instance.get(
    `/customers/${customer_id}/entities/${entity_id}?${getExpandStr2(
      params?.expand
    )}`
  );
};
var createEntity = async ({
  instance,
  customer_id,
  params
}) => {
  return instance.post(`/customers/${customer_id}/entities`, params);
};
var deleteEntity = async ({
  instance,
  customer_id,
  entity_id
}) => {
  return instance.delete(`/customers/${customer_id}/entities/${entity_id}`);
};
var transferProduct = async ({
  instance,
  customer_id,
  params
}) => {
  return instance.post(`/customers/${customer_id}/transfer`, params);
};

// src/sdk/products/prodMethods.ts
var productMethods = (instance) => {
  return {
    get: (id) => staticWrapper(getProduct, instance, { id }),
    create: (params) => staticWrapper(createProduct, instance, { params }),
    list: (params) => staticWrapper(listProducts, instance, { params }),
    delete: (id) => staticWrapper(deleteProduct, instance, { id })
  };
};
var listProducts = async ({
  instance,
  params
}) => {
  let path = "/products_beta";
  if (params) {
    const queryParams = new URLSearchParams();
    for (const [key, value] of Object.entries(params)) {
      if (value !== void 0) {
        queryParams.append(key, String(value));
      }
    }
    const queryString2 = queryParams.toString();
    if (queryString2) {
      path += `?${queryString2}`;
    }
  }
  return instance.get(path);
};
var getProduct = async ({
  instance,
  id
}) => {
  return instance.get(`/products/${id}`);
};
var createProduct = async ({
  instance,
  params
}) => {
  return instance.post("/products", params);
};
var deleteProduct = async ({
  instance,
  id,
  params
}) => {
  const path = buildPathWithQuery(`/products/${id}`, params);
  return instance.delete(path);
};

// src/sdk/referrals/referralMethods.ts
var referralMethods = (instance) => {
  return {
    createCode: (params) => staticWrapper(createReferralCode, instance, { params }),
    redeemCode: (params) => staticWrapper(redeemReferralCode, instance, { params })
  };
};
var createReferralCode = async ({
  instance,
  params
}) => {
  return instance.post("/referrals/code", params);
};
var redeemReferralCode = async ({
  instance,
  params
}) => {
  return instance.post("/referrals/redeem", params);
};

// src/sdk/response.ts
var toContainerResult = async ({
  response,
  logger: logger2,
  logError = true
}) => {
  if (response.status < 200 || response.status >= 300) {
    let error;
    try {
      error = await response.json();
      if (logError) {
        logger2.error(`[Autumn] ${error.message}`);
      }
    } catch (error2) {
      throw error2;
    }
    return {
      data: null,
      error: new AutumnError({
        message: error.message,
        code: error.code
      }),
      statusCode: response.status
    };
  }
  try {
    const data = await response.json();
    return {
      data,
      error: null,
      statusCode: response?.status
    };
  } catch (error) {
    throw error;
  }
};

// src/utils/logger.ts
var getTime = () => {
  const timeString = (/* @__PURE__ */ new Date()).toISOString();
  return `[${timeString.split("T")[1].split(".")[0]}]`;
};
var greaterThanLevel = (level) => {
  return levels.indexOf(level) >= levels.indexOf(logger.level);
};
var levels = ["debug", "info", "warn", "error", "fatal"];
var logger = {
  ...console,
  level: "info",
  debug: (...args) => {
    if (greaterThanLevel("debug")) {
      console.log(getTime(), "DEBUG", ...args);
    }
  },
  log: (...args) => {
    console.log(getTime(), "INFO", ...args);
  },
  info: (...args) => {
    if (greaterThanLevel("info")) {
      console.log(getTime(), "INFO", ...args);
    }
  },
  warn: (...args) => {
    if (greaterThanLevel("warn")) {
      console.log(getTime(), "WARN", ...args);
    }
  },
  error: (...args) => {
    if (greaterThanLevel("error")) {
      console.log(getTime(), "ERROR", ...args);
    }
  }
};

// src/sdk/features/featureMethods.ts
var featureMethods = (instance) => {
  return {
    list: () => staticWrapper(listFeatures, instance, {}),
    get: (id) => staticWrapper(getFeature, instance, { id })
  };
};
var listFeatures = async ({
  instance,
  params
}) => {
  let path = "/features";
  if (params) {
    const queryParams = new URLSearchParams();
    for (const [key, value] of Object.entries(params)) {
      if (value !== void 0) {
        queryParams.append(key, String(value));
      }
    }
    const queryString2 = queryParams.toString();
    if (queryString2) {
      path += `?${queryString2}`;
    }
  }
  return instance.get(path);
};
var getFeature = async ({
  instance,
  id
}) => {
  return instance.get(`/features/${id}`);
};

// src/sdk/events/eventMethods.ts
var eventMethods = (instance) => {
  return {
    list: (params) => staticWrapper(handleEventList, instance, { params }),
    aggregate: (params) => staticWrapper(handleEventAggregate, instance, { params })
  };
};
var handleEventList = async ({
  instance,
  params
}) => {
  return instance.post("/events/list", params);
};
var handleEventAggregate = async ({
  instance,
  params
}) => {
  return instance.post("/events/aggregate", params);
};

// src/sdk/balances/balancesMethods.ts
var balanceMethods = (instance) => {
  return {
    create: (params) => staticWrapper(handleCreateBalance, instance, { params })
  };
};
var handleCreateBalance = async ({
  instance,
  params
}) => {
  return instance.post("/balances/create", params);
};

// src/sdk/client.ts
var LATEST_API_VERSION = "1.2";
var Autumn = class {
  secretKey;
  publishableKey;
  headers;
  url;
  logger = console;
  defaultReturnUrl;
  constructor(options) {
    try {
      this.secretKey = options?.secretKey || process.env.AUTUMN_SECRET_KEY;
      this.publishableKey = options?.publishableKey || process.env.AUTUMN_PUBLISHABLE_KEY;
    } catch (error) {
    }
    if (!this.secretKey && !this.publishableKey && !options?.headers) {
      throw new Error("Autumn secret key or publishable key is required");
    }
    this.headers = options?.headers || {
      Authorization: `Bearer ${this.secretKey || this.publishableKey}`,
      "Content-Type": "application/json"
    };
    let version = options?.version || LATEST_API_VERSION;
    this.headers["x-api-version"] = version;
    this.url = options?.url || autumnApiUrl;
    this.logger = logger;
    this.logger.level = options?.logLevel || "info";
    this.defaultReturnUrl = options?.defaultReturnUrl;
  }
  async get(path) {
    const response = await fetch(`${this.url}${path}`, {
      headers: this.headers
    });
    return toContainerResult({ response, logger: this.logger });
  }
  async post(path, body) {
    try {
      const response = await fetch(`${this.url}${path}`, {
        method: "POST",
        headers: this.headers,
        body: JSON.stringify(body)
      });
      return toContainerResult({ response, logger: this.logger });
    } catch (error) {
      console.error("Error sending request:", error);
      throw error;
    }
  }
  async delete(path) {
    const response = await fetch(`${this.url}${path}`, {
      method: "DELETE",
      headers: this.headers
    });
    return toContainerResult({ response, logger: this.logger });
  }
  static customers = customerMethods();
  static products = productMethods();
  static entities = entityMethods();
  static referrals = referralMethods();
  static features = featureMethods();
  static events = eventMethods();
  static balances = balanceMethods();
  customers = customerMethods(this);
  products = productMethods(this);
  entities = entityMethods(this);
  referrals = referralMethods(this);
  features = featureMethods(this);
  events = eventMethods(this);
  balances = balanceMethods(this);
  /**
   * Initiates a checkout flow for a product purchase.
   * 
   * The checkout function handles the purchase process for products with pricing.
   * It determines whether to show a dialog for user input or redirect directly
   * to Stripe based on the customer's state and product requirements.
   * 
   * @param params - Checkout parameters including product ID, customer data, and options
   * @returns Promise resolving to checkout details including pricing, prorations, and URLs
   * 
   * @example
   * ```typescript
   * const result = await autumn.checkout({
   *   customer_id: "user_123",
   *   product_id: "pro",
   *   success_url: "https://myapp.com/success"
   * });
   * 
   * if (result.url) {
   *   // Redirect to Stripe checkout
   *   window.location.href = result.url;
   * }
   * ```
   */
  async checkout(params) {
    return handleCheckout({
      instance: this,
      params
    });
  }
  static checkout = (params) => staticWrapper(handleCheckout, void 0, { params });
  static usage = (params) => staticWrapper(handleUsage, void 0, { params });
  /**
   * Attaches a product to a customer, enabling access and handling billing.
   * 
   * The attach function activates a product for a customer and applies all product items.
   * When you attach a product:
   * - The customer gains access to all features in the product
   * - If the product has prices, the customer will be billed accordingly  
   * - If there's no existing payment method, a checkout URL will be generated
   * 
   * @param params - Attach parameters including customer ID, product ID, and options
   * @returns Promise resolving to attachment result with checkout URL if needed
   * 
   * @example
   * ```typescript
   * const result = await autumn.attach({
   *   customer_id: "user_123",
   *   product_id: "pro",
   *   success_url: "https://myapp.com/success"
   * });
   * 
   * if (result.checkout_url) {
   *   // Payment required - redirect to checkout
   *   window.location.href = result.checkout_url;
   * } else {
   *   // Product successfully attached
   *   console.log("Access granted:", result.message);
   * }
   * ```
   */
  async attach(params) {
    return handleAttach({
      instance: this,
      params
    });
  }
  static attach = (params) => staticWrapper(handleAttach, void 0, { params });
  static setupPayment = (params) => staticWrapper(handleSetupPayment, void 0, { params });
  /**
   * Sets up a payment method for a customer.
   * 
   * This method allows you to set up payment methods for customers without 
   * immediately charging them. Useful for collecting payment information
   * before product attachment or for updating existing payment methods.
   * 
   * @param params - Setup payment parameters including customer information
   * @returns Promise resolving to setup payment result
   * 
   * @example
   * ```typescript
   * const result = await autumn.setupPayment({
   *   customer_id: "user_123"
   * });
   * ```
   */
  async setupPayment(params) {
    return handleSetupPayment({
      instance: this,
      params
    });
  }
  static cancel = (params) => staticWrapper(handleCancel, void 0, { params });
  /**
   * Cancels a customer's subscription or product attachment.
   * 
   * This method allows you to cancel a customer's subscription to a specific product.
   * You can choose to cancel immediately or at the end of the billing cycle.
   * 
   * @param params - Cancel parameters including customer ID and product ID
   * @returns Promise resolving to cancellation result
   * 
   * @example
   * ```typescript
   * const result = await autumn.cancel({
   *   customer_id: "user_123",
   *   product_id: "pro",
   *   cancel_immediately: false // Cancel at end of billing cycle
   * });
   * ```
   */
  async cancel(params) {
    return handleCancel({
      instance: this,
      params
    });
  }
  static check = (params) => staticWrapper(handleCheck, void 0, { params });
  /**
   * Checks if a customer has access to a specific feature.
   * 
   * This method verifies whether a customer has permission to use a feature
   * and checks their remaining balance/usage limits. It can be used to gate
   * features and determine when to show upgrade prompts.
   * 
   * @param params - Check parameters including customer ID and feature ID
   * @returns Promise resolving to access check result with allowed status and balance info
   * 
   * @example
   * ```typescript
   * const result = await autumn.check({
   *   customer_id: "user_123",
   *   feature_id: "messages",
   *   required_balance: 1
   * });
   * 
   * if (!result.allowed) {
   *   console.log("Feature access denied - upgrade required");
   * }
   * ```
   */
  async check(params) {
    return handleCheck({
      instance: this,
      params
    });
  }
  static track = (params) => staticWrapper(handleTrack, void 0, { params });
  /**
   * Tracks usage events for features or analytics.
   * 
   * This method records usage events for metered features, updating the customer's
   * balance and usage statistics. It's typically used server-side to ensure
   * accurate tracking that cannot be manipulated by users.
   * 
   * @param params - Track parameters including customer ID, feature ID, and usage value
   * @returns Promise resolving to tracking result
   * 
   * @example
   * ```typescript
   * const result = await autumn.track({
   *   customer_id: "user_123",
   *   feature_id: "messages",
   *   value: 1 // Track 1 message sent
   * });
   * ```
   */
  async track(params) {
    return handleTrack({
      instance: this,
      params
    });
  }
  /**
   * Retrieves usage statistics and analytics for a customer.
   * 
   * This method fetches detailed usage information for a customer's features,
   * including current balances, usage history, and analytics data. Useful
   * for displaying usage dashboards or generating reports.
   * 
   * @param params - Usage parameters including customer ID and optional filters
   * @returns Promise resolving to usage statistics and analytics data
   * 
   * @example
   * ```typescript
   * const result = await autumn.usage({
   *   customer_id: "user_123",
   *   feature_id: "messages" 
   *   value: 20 // Usage value
   * });
   * ```
   */
  async usage(params) {
    return handleUsage({
      instance: this,
      params
    });
  }
  static query = (params) => staticWrapper(handleQuery, void 0, { params });
  /**
   * Performs advanced queries on customer data and analytics.
   * 
   * This method allows you to run complex queries against customer data,
   * usage patterns, and billing information. Useful for generating reports,
   * analytics, and custom data insights.
   * 
   * @param params - Query parameters including customer ID and query specifications
   * @returns Promise resolving to query results with requested data
   * 
   * @example
   * ```typescript
   * const result = await autumn.query({
   *   customer_id: "user_123",
   *   feature_id: "messages" // feature id to fetch for query, can also be an array
   * });
   * 
   * ```
   */
  async query(params) {
    return handleQuery({
      instance: this,
      params
    });
  }
};

// src/sdk/customers/cusEnums.ts
var import_v4 = require("zod/v4");
var CustomerExpandEnum = import_v4.z.enum([
  "invoices",
  "rewards",
  "trials_used",
  "entities",
  "referrals",
  "payment_method"
]);

// src/sdk/customers/cusTypes.ts
var import_v42 = require("zod/v4");

// src/sdk/products/prodEnums.ts
var ProductItemInterval = /* @__PURE__ */ ((ProductItemInterval2) => {
  ProductItemInterval2["Minute"] = "minute";
  ProductItemInterval2["Hour"] = "hour";
  ProductItemInterval2["Day"] = "day";
  ProductItemInterval2["Week"] = "week";
  ProductItemInterval2["Month"] = "month";
  ProductItemInterval2["Quarter"] = "quarter";
  ProductItemInterval2["SemiAnnual"] = "semi_annual";
  ProductItemInterval2["Year"] = "year";
  ProductItemInterval2["Multiple"] = "multiple";
  return ProductItemInterval2;
})(ProductItemInterval || {});

// src/sdk/customers/cusTypes.ts
var CoreCusFeatureSchema = import_v42.z.object({
  unlimited: import_v42.z.boolean().optional(),
  interval: import_v42.z.enum(ProductItemInterval).optional(),
  balance: import_v42.z.number().nullish(),
  usage: import_v42.z.number().optional(),
  included_usage: import_v42.z.number().optional(),
  next_reset_at: import_v42.z.number().nullish(),
  overage_allowed: import_v42.z.boolean().optional(),
  usage_limit: import_v42.z.number().optional(),
  rollovers: import_v42.z.object({
    balance: import_v42.z.number(),
    expires_at: import_v42.z.number()
  }).optional(),
  breakdown: import_v42.z.array(
    import_v42.z.object({
      interval: import_v42.z.enum(ProductItemInterval),
      balance: import_v42.z.number().optional(),
      usage: import_v42.z.number().optional(),
      included_usage: import_v42.z.number().optional(),
      next_reset_at: import_v42.z.number().optional()
    })
  ).optional(),
  credit_schema: import_v42.z.array(
    import_v42.z.object({
      feature_id: import_v42.z.string(),
      credit_amount: import_v42.z.number()
    })
  ).optional()
});
var CustomerDataSchema = import_v42.z.object({
  name: import_v42.z.string().nullish(),
  email: import_v42.z.string().nullish(),
  fingerprint: import_v42.z.string().nullish()
});
var CreateCustomerParamsSchema = import_v42.z.object({
  id: import_v42.z.string().nullish(),
  email: import_v42.z.string().nullish(),
  name: import_v42.z.string().nullish(),
  fingerprint: import_v42.z.string().nullish(),
  metadata: import_v42.z.record(import_v42.z.string(), import_v42.z.any()).optional(),
  expand: import_v42.z.array(CustomerExpandEnum).optional(),
  stripe_id: import_v42.z.string().nullish(),
  auto_enable_plan_id: import_v42.z.string().optional()
});
var BillingPortalParamsSchema = import_v42.z.object({
  return_url: import_v42.z.string().optional()
});
var UpdateBalancesParamsSchema = import_v42.z.object({
  feature_id: import_v42.z.string(),
  balance: import_v42.z.number()
}).or(
  import_v42.z.array(
    import_v42.z.object({
      feature_id: import_v42.z.string(),
      balance: import_v42.z.number()
    })
  )
).or(
  import_v42.z.object({
    entity_id: import_v42.z.string().optional(),
    balances: import_v42.z.array(
      import_v42.z.object({
        feature_id: import_v42.z.string(),
        balance: import_v42.z.number()
      })
    )
  })
);
var DeleteCustomerParamsSchema = import_v42.z.object({
  delete_in_stripe: import_v42.z.boolean().optional()
});
var ListCustomersParamsSchema = import_v42.z.object({
  limit: import_v42.z.number().optional(),
  offset: import_v42.z.number().optional()
});

// src/sdk/customers/entities/entTypes.ts
var import_v43 = require("zod/v4");
var EntityDataSchema = import_v43.z.object({
  name: import_v43.z.string().optional(),
  feature_id: import_v43.z.string()
});
var TransferProductParamsSchema = import_v43.z.object({
  from_entity_id: import_v43.z.string(),
  to_entity_id: import_v43.z.string(),
  product_id: import_v43.z.string()
});

// src/sdk/general/pageTypes.ts
var import_v44 = require("zod/v4");
var PagePaginationDefaults = {
  Limit: 100,
  MaxLimit: 1e3
};
var PagePaginationQuerySchema = import_v44.z.object({
  offset: import_v44.z.coerce.number().int().min(0).default(0).describe("Number of items to skip"),
  limit: import_v44.z.coerce.number().int().min(1).max(PagePaginationDefaults.MaxLimit).default(PagePaginationDefaults.Limit).describe(
    `Number of items to return. Default ${PagePaginationDefaults.Limit}, max ${PagePaginationDefaults.MaxLimit}.`
  )
});
var createPagePaginatedResponseSchema = (itemSchema) => import_v44.z.object({
  list: import_v44.z.array(itemSchema).describe("Array of items for current page"),
  has_more: import_v44.z.boolean().describe("Whether more results exist after this page"),
  offset: import_v44.z.number().describe("Current offset position"),
  limit: import_v44.z.number().describe("Limit passed in the request"),
  total: import_v44.z.number().describe("Total number of items returned in the current page")
});

// src/sdk/events/eventTypes.ts
var import_v45 = require("zod/v4");
var QueryRangeEnum = import_v45.z.enum([
  "24h",
  "7d",
  "30d",
  "90d",
  "last_cycle",
  "1bc",
  "3bc"
]);
var BinSizeEnum = import_v45.z.enum(["day", "hour"]);
var QueryParamsSchema = import_v45.z.object({
  customer_id: import_v45.z.string(),
  feature_id: import_v45.z.string().or(import_v45.z.array(import_v45.z.string())),
  range: QueryRangeEnum.optional(),
  group_by: import_v45.z.string().startsWith("properties.").optional(),
  bin_size: BinSizeEnum.optional(),
  custom_range: import_v45.z.object({
    start: import_v45.z.number(),
    end: import_v45.z.number()
  }).optional()
});
var EventsListParamsSchema = PagePaginationQuerySchema.extend({
  customer_id: import_v45.z.string(),
  feature_id: import_v45.z.string().or(import_v45.z.array(import_v45.z.string())),
  custom_range: import_v45.z.object({
    start: import_v45.z.coerce.number().optional(),
    end: import_v45.z.coerce.number().optional()
  }).optional()
});
var EventsListItemSchema = import_v45.z.object({
  id: import_v45.z.string().describe("Event ID (KSUID)"),
  timestamp: import_v45.z.number().describe("Event timestamp (epoch milliseconds)"),
  feature_id: import_v45.z.string().describe("Name of the event"),
  customer_id: import_v45.z.string().describe("Customer identifier"),
  value: import_v45.z.number().describe("Event value/count"),
  properties: import_v45.z.object({}).describe("Event properties (JSONB)")
});
var EventsListResponseSchema = createPagePaginatedResponseSchema(EventsListItemSchema);

// src/sdk/features/featureTypes.ts
var import_v46 = require("zod/v4");
var FeatureType = /* @__PURE__ */ ((FeatureType2) => {
  FeatureType2["Boolean"] = "boolean";
  FeatureType2["SingleUse"] = "single_use";
  FeatureType2["ContinuousUse"] = "continuous_use";
  FeatureType2["CreditSystem"] = "credit_system";
  return FeatureType2;
})(FeatureType || {});
var FeatureSchema = import_v46.z.object({
  id: import_v46.z.string(),
  name: import_v46.z.string(),
  type: import_v46.z.enum(FeatureType),
  display: import_v46.z.object({
    singular: import_v46.z.string(),
    plural: import_v46.z.string()
  }).nullish(),
  credit_schema: import_v46.z.array(
    import_v46.z.object({
      metered_feature_id: import_v46.z.string(),
      credit_cost: import_v46.z.number()
    })
  ).nullish(),
  archived: import_v46.z.boolean()
});

// src/sdk/general/attachTypes.ts
var import_v47 = require("zod/v4");
var AttachFeatureOptionsSchema = import_v47.z.object({
  feature_id: import_v47.z.string(),
  quantity: import_v47.z.number()
});
var AttachParamsSchema = import_v47.z.object({
  customer_id: import_v47.z.string(),
  product_id: import_v47.z.string().optional(),
  entity_id: import_v47.z.string().optional(),
  options: import_v47.z.array(AttachFeatureOptionsSchema).optional(),
  product_ids: import_v47.z.array(import_v47.z.string()).optional(),
  free_trial: import_v47.z.boolean().optional(),
  success_url: import_v47.z.string().optional(),
  metadata: import_v47.z.record(import_v47.z.string(), import_v47.z.string()).optional(),
  force_checkout: import_v47.z.boolean().optional(),
  customer_data: CustomerDataSchema.optional(),
  entity_data: import_v47.z.any().optional(),
  checkout_session_params: import_v47.z.record(import_v47.z.string(), import_v47.z.any()).optional(),
  reward: import_v47.z.string().optional(),
  invoice: import_v47.z.boolean().optional(),
  new_billing_subscription: import_v47.z.boolean().optional()
});
var AttachResultSchema = import_v47.z.object({
  checkout_url: import_v47.z.string().optional(),
  customer_id: import_v47.z.string(),
  product_ids: import_v47.z.array(import_v47.z.string()),
  code: import_v47.z.string(),
  message: import_v47.z.string(),
  customer_data: import_v47.z.any().optional(),
  invoice: import_v47.z.object({
    status: import_v47.z.string(),
    stripe_id: import_v47.z.string(),
    hosted_invoice_url: import_v47.z.string().nullable(),
    total: import_v47.z.number(),
    currency: import_v47.z.string()
  }).optional()
});
var CheckoutParamsSchema = import_v47.z.object({
  customer_id: import_v47.z.string(),
  product_id: import_v47.z.string(),
  product_ids: import_v47.z.array(import_v47.z.string()).optional(),
  entity_id: import_v47.z.string().optional(),
  options: import_v47.z.array(AttachFeatureOptionsSchema).optional(),
  force_checkout: import_v47.z.boolean().optional(),
  invoice: import_v47.z.boolean().optional(),
  success_url: import_v47.z.string().optional(),
  customer_data: CustomerDataSchema.optional(),
  entity_data: import_v47.z.any().optional(),
  checkout_session_params: import_v47.z.record(import_v47.z.string(), import_v47.z.any()).optional(),
  reward: import_v47.z.string().optional(),
  new_billing_subscription: import_v47.z.boolean().optional()
});

// src/sdk/general/checkTypes.ts
var import_v48 = require("zod/v4");
var CheckFeatureResultSchema = import_v48.z.object({
  allowed: import_v48.z.boolean(),
  feature_id: import_v48.z.string(),
  customer_id: import_v48.z.string(),
  entity_id: import_v48.z.string().optional(),
  required_balance: import_v48.z.number()
}).extend(CoreCusFeatureSchema.shape);

// src/sdk/general/genTypes.ts
var import_v49 = require("zod/v4");
var CancelParamsSchema = import_v49.z.object({
  customer_id: import_v49.z.string(),
  product_id: import_v49.z.string(),
  entity_id: import_v49.z.string().optional(),
  cancel_immediately: import_v49.z.boolean().optional()
});
var CancelResultSchema = import_v49.z.object({
  success: import_v49.z.boolean(),
  customer_id: import_v49.z.string(),
  product_id: import_v49.z.string()
});
var TrackParamsSchema = import_v49.z.object({
  customer_id: import_v49.z.string(),
  value: import_v49.z.number().optional(),
  feature_id: import_v49.z.string().optional(),
  event_name: import_v49.z.string().optional(),
  entity_id: import_v49.z.string().optional(),
  customer_data: import_v49.z.any().optional(),
  idempotency_key: import_v49.z.string().optional(),
  entity_data: import_v49.z.any().optional(),
  properties: import_v49.z.record(import_v49.z.string(), import_v49.z.any()).optional()
});
var TrackResultSchema = import_v49.z.object({
  id: import_v49.z.string(),
  code: import_v49.z.string(),
  customer_id: import_v49.z.string(),
  feature_id: import_v49.z.string().optional(),
  event_name: import_v49.z.string().optional()
});
var CheckParamsSchema = import_v49.z.object({
  customer_id: import_v49.z.string(),
  feature_id: import_v49.z.string().optional(),
  product_id: import_v49.z.string().optional(),
  entity_id: import_v49.z.string().optional(),
  customer_data: import_v49.z.any().optional(),
  required_balance: import_v49.z.number().optional(),
  send_event: import_v49.z.boolean().optional(),
  with_preview: import_v49.z.boolean().optional(),
  entity_data: EntityDataSchema.optional()
});

// src/sdk/referrals/referralTypes.ts
var import_v410 = require("zod/v4");
var CreateReferralCodeParamsSchema = import_v410.z.object({
  customer_id: import_v410.z.string(),
  program_id: import_v410.z.string()
});
var RedeemReferralCodeParamsSchema = import_v410.z.object({
  code: import_v410.z.string(),
  customer_id: import_v410.z.string()
});

// src/sdk/balances/balancesTypes.ts
var import_v411 = require("zod/v4");
var ResetInterval = [
  "one_off",
  "minute",
  "hour",
  "day",
  "week",
  "month",
  "quarter",
  "semi_annual",
  "year"
];
var CreateBalanceParamsSchema = import_v411.z.object({
  feature_id: import_v411.z.string().describe("The feature ID to create the balance for"),
  customer_id: import_v411.z.string().describe("The customer ID to assign the balance to"),
  entity_id: import_v411.z.string().optional().describe("Entity ID for entity-scoped balances"),
  granted_balance: import_v411.z.number().optional().describe("The initial balance amount to grant"),
  unlimited: import_v411.z.boolean().optional().describe("Whether the balance is unlimited"),
  reset: import_v411.z.object({
    interval: import_v411.z.enum(ResetInterval),
    interval_count: import_v411.z.number().optional()
  }).optional().describe("Reset configuration for the balance"),
  expires_at: import_v411.z.number().optional().describe("Unix timestamp (milliseconds) when the balance expires")
});

// src/libraries/backend/utils/backendRes.ts
var toBackendRes = ({ res }) => {
  let statusCode = res.statusCode ? res.statusCode : res.error ? 500 : 200;
  return {
    body: res.data ? res.data : res.error,
    statusCode
  };
};
var toBackendError = ({
  path,
  message,
  code,
  statusCode = 500
}) => {
  return {
    statusCode,
    body: new AutumnError({
      message: message || "Internal server error",
      code: code || "internal_server_error"
    })
  };
};

// src/utils/toSnakeCase.ts
function stringToSnakeCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1_$2").replace(/[-\s]+/g, "_").toLowerCase();
}
var toSnakeCase = ({
  obj,
  excludeKeys,
  excludeChildrenOf
}) => {
  if (Array.isArray(obj)) {
    return obj.map(
      (item) => toSnakeCase({ obj: item, excludeKeys, excludeChildrenOf })
    );
  } else if (obj !== null && typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => {
        const snakeKey = stringToSnakeCase(key);
        if (excludeKeys?.includes(key)) {
          return [key, value];
        }
        if (excludeChildrenOf?.includes(key)) {
          return [snakeKey, value];
        }
        return [
          snakeKey,
          toSnakeCase({
            obj: value,
            excludeKeys,
            excludeChildrenOf
          })
        ];
      })
    );
  }
  return obj;
};

// src/libraries/backend/utils/withAuth.ts
var withAuth = ({
  fn,
  requireCustomer = true,
  suppressLogs = false
}) => {
  return async ({
    autumn,
    body,
    path,
    getCustomer: getCustomer2,
    pathParams,
    searchParams
  }) => {
    let authResult = await getCustomer2();
    let customerId = authResult?.customerId;
    if (!customerId && requireCustomer) {
      if (body?.errorOnNotFound === false) {
        return {
          statusCode: 202,
          body: null
        };
      } else {
        if (!suppressLogs) {
          logger.error(
            `[Autumn]: customerId returned from identify function is ${customerId}`
          );
        }
        return toBackendError({
          path,
          message: `customerId returned from identify function is ${customerId}`,
          code: "no_customer_id",
          statusCode: 401
        });
      }
    }
    let cusData = authResult?.customerData || body?.customer_data;
    if (body) {
      body = toSnakeCase({
        obj: body,
        excludeChildrenOf: ["checkoutSessionParams", "properties"]
      });
    }
    try {
      let res = await fn({
        body,
        autumn,
        customer_id: customerId,
        customer_data: cusData,
        pathParams,
        searchParams
      });
      return toBackendRes({ res });
    } catch (error) {
      if (!suppressLogs) {
        logger.error(`${error.message}`);
      }
      return toBackendError({
        path,
        message: error.message || "unknown error",
        code: "internal_error"
      });
    }
  };
};

// src/libraries/backend/routes/entityRoutes.ts
var createEntityHandler = (options) => withAuth({
  fn: async ({
    autumn,
    customer_id,
    body
  }) => {
    return await autumn.entities.create(customer_id, body);
  },
  suppressLogs: options?.suppressLogs
});
var getEntityHandler = (options) => withAuth({
  fn: async ({
    autumn,
    customer_id,
    pathParams,
    searchParams
  }) => {
    if (!pathParams?.entityId) {
      return {
        statusCode: 400,
        body: {
          error: "no_entity_id",
          message: "Entity ID is required"
        }
      };
    }
    let params = {
      expand: searchParams?.expand?.split(",")
    };
    let res = await autumn.entities.get(
      customer_id,
      pathParams.entityId,
      params
    );
    return res;
  },
  suppressLogs: options?.suppressLogs
});
var deleteEntityHandler = (options) => withAuth({
  fn: async ({
    autumn,
    customer_id,
    pathParams
  }) => {
    if (!pathParams?.entityId) {
      return {
        statusCode: 400,
        body: {
          error: "no_entity_id",
          message: "Entity ID is required"
        }
      };
    }
    return await autumn.entities.delete(customer_id, pathParams.entityId);
  },
  suppressLogs: options?.suppressLogs
});
var addEntityRoutes = async (router, options) => {
  (0, import_rou3.addRoute)(router, "POST", "/api/autumn/entities", {
    handler: createEntityHandler(options)
  });
  (0, import_rou3.addRoute)(router, "GET", "/api/autumn/entities/:entityId", {
    handler: getEntityHandler(options)
  });
  (0, import_rou3.addRoute)(router, "DELETE", "/api/autumn/entities/:entityId", {
    handler: deleteEntityHandler(options)
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addEntityRoutes
});
