import { z } from 'zod/v4';
import { R as Result, A as AutumnError, a as AutumnPromise } from './response-BBvvMvoC.mjs';

declare const Infinite = "inf";
declare enum FreeTrialDuration {
    Day = "day"
}
declare enum UsageModel {
    Prepaid = "prepaid",
    PayPerUse = "pay_per_use"
}
type UsageModelType = "prepaid" | "pay_per_use";
declare enum ProductItemInterval {
    Minute = "minute",
    Hour = "hour",
    Day = "day",
    Week = "week",
    Month = "month",
    Quarter = "quarter",
    SemiAnnual = "semi_annual",
    Year = "year",
    Multiple = "multiple"
}
type ProductItemIntervalType = "minute" | "hour" | "day" | "week" | "month" | "quarter" | "semi_annual" | "year" | "multiple";

declare const CheckFeatureResultSchema: z.ZodObject<{
    allowed: z.ZodBoolean;
    feature_id: z.ZodString;
    customer_id: z.ZodString;
    entity_id: z.ZodOptional<z.ZodString>;
    required_balance: z.ZodNumber;
    unlimited: z.ZodOptional<z.ZodBoolean>;
    interval: z.ZodOptional<z.ZodEnum<typeof ProductItemInterval>>;
    balance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    usage: z.ZodOptional<z.ZodNumber>;
    included_usage: z.ZodOptional<z.ZodNumber>;
    next_reset_at: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    overage_allowed: z.ZodOptional<z.ZodBoolean>;
    usage_limit: z.ZodOptional<z.ZodNumber>;
    rollovers: z.ZodOptional<z.ZodObject<{
        balance: z.ZodNumber;
        expires_at: z.ZodNumber;
    }, z.core.$strip>>;
    breakdown: z.ZodOptional<z.ZodArray<z.ZodObject<{
        interval: z.ZodEnum<typeof ProductItemInterval>;
        balance: z.ZodOptional<z.ZodNumber>;
        usage: z.ZodOptional<z.ZodNumber>;
        included_usage: z.ZodOptional<z.ZodNumber>;
        next_reset_at: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>>;
    credit_schema: z.ZodOptional<z.ZodArray<z.ZodObject<{
        feature_id: z.ZodString;
        credit_amount: z.ZodNumber;
    }, z.core.$strip>>>;
}, z.core.$strip>;
type CheckFeatureResult = z.infer<typeof CheckFeatureResultSchema>;
type ProductScenario = "scheduled" | "active" | "new" | "renew" | "upgrade" | "downgrade" | "cancel";
interface CheckProductResult {
    allowed: boolean;
    customer_id: string;
    product_id: string;
    entity_id?: string;
    status?: string;
    preview?: CheckProductPreview;
}
interface CheckProductPreview {
    scenario: ProductScenario;
    product_id: string;
    product_name: string;
    recurring: boolean;
    error_on_attach?: boolean;
    next_cycle_at?: number;
    current_product_name?: string;
    items?: {
        price: string;
        description: string;
        usage_model?: UsageModelType;
    }[];
    options?: {
        feature_id: string;
        feature_name: string;
        billing_units: number;
        price?: number;
        tiers?: {
            to: number | string;
            amount: number;
        }[];
    }[];
    due_today?: {
        price: number;
        currency: string;
    };
    due_next_cycle?: {
        price: number;
        currency: string;
    };
}

declare enum AppEnv {
    Sandbox = "sandbox",
    Live = "live"
}

interface Feature$1 {
    id: string;
    name: string;
    type: "boolean" | "continuous_use" | "single_use" | "credit_system";
}
interface ProductItem {
    type?: "feature" | "priced_feature" | "price";
    feature_id?: string;
    included_usage?: number | typeof Infinite;
    interval?: ProductItemIntervalType;
    feature?: Feature$1;
    usage_model?: UsageModel;
    price?: number;
    billing_units?: number;
    entity_feature_id?: string;
    reset_usage_when_enabled?: boolean;
    quantity?: number;
    next_cycle_quantity?: number;
    display?: {
        primary_text?: string;
        secondary_text?: string;
    };
}
interface FreeTrial {
    duration: FreeTrialDuration;
    length: number;
    unique_fingerprint: boolean;
    trial_available?: boolean;
}
interface Product {
    id: string;
    created_at: number;
    name: string;
    env: AppEnv;
    is_add_on: boolean;
    is_default: boolean;
    group: string;
    version: number;
    items: ProductItem[];
    free_trial: FreeTrial | null;
    scenario?: ProductScenario;
    base_variant_id: string | null;
    properties: {
        is_free: boolean;
        is_one_off: boolean;
        interval_group: string;
        has_trial: boolean;
        updateable: boolean;
    };
    display?: {
        name?: string;
        description?: string;
        button_text?: string;
        recommend_text?: string;
        everything_from?: string;
        button_url?: string;
    };
}
interface CreateProductParams {
    id: string;
    name?: string;
    is_add_on?: boolean;
    is_default?: boolean;
    items?: ProductItem[];
    free_trial?: FreeTrial;
}
interface ListProductsParams {
    customer_id?: string;
}

declare enum ProductStatus {
    Active = "active",
    Expired = "expired",
    Trialing = "trialing",
    Scheduled = "scheduled",
    PastDue = "past_due"
}
type CustomerExpandOption = "invoices" | "rewards" | "trials_used" | "entities" | "referrals" | "payment_method";

type EntityExpandOption = "invoices";

interface CreateEntityParams {
    id: string;
    name: string;
    feature_id: string;
    customer_data?: CustomerData;
}
interface CreateEntityResult {
    success: boolean;
}
interface DeleteEntityResult {
    success: boolean;
}
interface GetEntityParams {
    expand?: EntityExpandOption[];
}
interface Entity {
    id: string;
    name: string;
    customer_id: string;
    created_at: number;
    env: string;
    products: CustomerProduct[];
    features: Record<string, CustomerFeature>;
    invoices?: CustomerInvoice[];
}
declare const TransferProductParamsSchema: z.ZodObject<{
    from_entity_id: z.ZodString;
    to_entity_id: z.ZodString;
    product_id: z.ZodString;
}, z.core.$strip>;
type TransferProductParams = z.infer<typeof TransferProductParamsSchema>;
type TransferProductResult = {
    success: boolean;
};

declare const CoreCusFeatureSchema: z.ZodObject<{
    unlimited: z.ZodOptional<z.ZodBoolean>;
    interval: z.ZodOptional<z.ZodEnum<typeof ProductItemInterval>>;
    balance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    usage: z.ZodOptional<z.ZodNumber>;
    included_usage: z.ZodOptional<z.ZodNumber>;
    next_reset_at: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    overage_allowed: z.ZodOptional<z.ZodBoolean>;
    usage_limit: z.ZodOptional<z.ZodNumber>;
    rollovers: z.ZodOptional<z.ZodObject<{
        balance: z.ZodNumber;
        expires_at: z.ZodNumber;
    }, z.core.$strip>>;
    breakdown: z.ZodOptional<z.ZodArray<z.ZodObject<{
        interval: z.ZodEnum<typeof ProductItemInterval>;
        balance: z.ZodOptional<z.ZodNumber>;
        usage: z.ZodOptional<z.ZodNumber>;
        included_usage: z.ZodOptional<z.ZodNumber>;
        next_reset_at: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>>;
    credit_schema: z.ZodOptional<z.ZodArray<z.ZodObject<{
        feature_id: z.ZodString;
        credit_amount: z.ZodNumber;
    }, z.core.$strip>>>;
}, z.core.$strip>;
type CoreCustomerFeature = z.infer<typeof CoreCusFeatureSchema>;
interface CustomerFeature extends CoreCustomerFeature {
    id: string;
    name: string;
    type: "static" | "single_use" | "continuous_use";
}
interface CustomerReferral {
    program_id: string;
    customer: {
        id: string;
        name: string | null;
        email: string | null;
    };
    reward_applied: boolean;
    created_at: number;
}
interface CustomerProduct {
    id: string;
    name: string | null;
    group: string | null;
    status: ProductStatus;
    started_at: number;
    canceled_at: number | null;
    version: number;
    subscription_ids?: string[] | null;
    current_period_start?: number | null;
    current_period_end?: number | null;
    trial_ends_at?: number;
    entity_id?: string;
    is_add_on: boolean;
    is_default: boolean;
    items: ProductItem[];
}
interface Customer {
    id: string | null;
    created_at: number;
    name: string | null;
    email: string | null;
    fingerprint: string | null;
    stripe_id: string | null;
    env: AppEnv;
    metadata: Record<string, any>;
    products: CustomerProduct[];
    features: Record<string, CustomerFeature>;
    payment_method?: any;
    referrals?: CustomerReferral[];
}
/**
 * Maps expand option strings to their corresponding types.
 * Used for conditional type expansion based on the expand parameter.
 */
interface CustomerExpandedFields {
    invoices: CustomerInvoice[];
    entities: Entity[];
    referrals: CustomerReferral[];
    rewards: unknown;
    trials_used: unknown;
    payment_method: unknown;
}
/**
 * Utility type that creates a Customer with additional expanded fields
 * based on the expand array passed to the API.
 *
 * @example
 * // Base customer without expanded fields
 * type Base = ExpandedCustomer<[]>;
 *
 * // Customer with invoices and entities expanded
 * type WithExpansion = ExpandedCustomer<['invoices', 'entities']>;
 * // Result: Customer & { invoices: CustomerInvoice[]; entities: Entity[] }
 */
type ExpandedCustomer<T extends readonly CustomerExpandOption[] = readonly []> = Customer & {
    [K in T[number]]: CustomerExpandedFields[K];
};
declare const CustomerDataSchema: z.ZodObject<{
    name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    email: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    fingerprint: z.ZodOptional<z.ZodNullable<z.ZodString>>;
}, z.core.$strip>;
type CustomerData = z.infer<typeof CustomerDataSchema>;
interface GetCustomerParams<T extends readonly CustomerExpandOption[] = readonly []> {
    expand?: T;
}
declare const CreateCustomerParamsSchema: z.ZodObject<{
    id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    email: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    fingerprint: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    expand: z.ZodOptional<z.ZodArray<z.ZodEnum<{
        invoices: "invoices";
        rewards: "rewards";
        trials_used: "trials_used";
        entities: "entities";
        referrals: "referrals";
        payment_method: "payment_method";
    }>>>;
    stripe_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    auto_enable_plan_id: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
type CreateCustomerParamsBase = z.infer<typeof CreateCustomerParamsSchema>;
/**
 * Generic version of CreateCustomerParams that preserves the expand array type
 * for proper ExpandedCustomer inference.
 */
interface CreateCustomerParams<T extends readonly CustomerExpandOption[] = readonly []> extends Omit<CreateCustomerParamsBase, "expand"> {
    expand?: T;
}
interface UpdateCustomerParams {
    id?: string | null;
    name?: string | null;
    email?: string | null;
    fingerprint?: string | null;
    metadata?: Record<string, any>;
    stripe_id?: string;
}
declare const BillingPortalParamsSchema: z.ZodObject<{
    return_url: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
type BillingPortalParams = z.infer<typeof BillingPortalParamsSchema>;
interface BillingPortalResult {
    customer_id: string;
    url: string;
}
interface CustomerInvoice {
    product_ids: string[];
    stripe_id: string;
    status: string;
    total: number;
    currency: string;
    created_at: number;
    hosted_invoice_url: string;
}
declare const UpdateBalancesParamsSchema: z.ZodUnion<[z.ZodUnion<[z.ZodObject<{
    feature_id: z.ZodString;
    balance: z.ZodNumber;
}, z.core.$strip>, z.ZodArray<z.ZodObject<{
    feature_id: z.ZodString;
    balance: z.ZodNumber;
}, z.core.$strip>>]>, z.ZodObject<{
    entity_id: z.ZodOptional<z.ZodString>;
    balances: z.ZodArray<z.ZodObject<{
        feature_id: z.ZodString;
        balance: z.ZodNumber;
    }, z.core.$strip>>;
}, z.core.$strip>]>;
declare const DeleteCustomerParamsSchema: z.ZodObject<{
    delete_in_stripe: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
declare const ListCustomersParamsSchema: z.ZodObject<{
    limit: z.ZodOptional<z.ZodNumber>;
    offset: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
type ListCustomersParams = z.infer<typeof ListCustomersParamsSchema>;
type DeleteCustomerParams = z.infer<typeof DeleteCustomerParamsSchema>;
type UpdateBalancesParams = z.infer<typeof UpdateBalancesParamsSchema>;
type UpdateBalancesResult = {
    success: boolean;
};

declare const CancelParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    product_id: z.ZodString;
    entity_id: z.ZodOptional<z.ZodString>;
    cancel_immediately: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
type CancelParams = z.infer<typeof CancelParamsSchema>;
declare const TrackParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    value: z.ZodOptional<z.ZodNumber>;
    feature_id: z.ZodOptional<z.ZodString>;
    event_name: z.ZodOptional<z.ZodString>;
    entity_id: z.ZodOptional<z.ZodString>;
    customer_data: z.ZodOptional<z.ZodAny>;
    idempotency_key: z.ZodOptional<z.ZodString>;
    entity_data: z.ZodOptional<z.ZodAny>;
    properties: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
}, z.core.$strip>;
type TrackParams = z.infer<typeof TrackParamsSchema>;
declare const CheckParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    feature_id: z.ZodOptional<z.ZodString>;
    product_id: z.ZodOptional<z.ZodString>;
    entity_id: z.ZodOptional<z.ZodString>;
    customer_data: z.ZodOptional<z.ZodAny>;
    required_balance: z.ZodOptional<z.ZodNumber>;
    send_event: z.ZodOptional<z.ZodBoolean>;
    with_preview: z.ZodOptional<z.ZodBoolean>;
    entity_data: z.ZodOptional<z.ZodObject<{
        name: z.ZodOptional<z.ZodString>;
        feature_id: z.ZodString;
    }, z.core.$strip>>;
}, z.core.$strip>;
type CheckParams = z.infer<typeof CheckParamsSchema>;
type CheckResult = CheckFeatureResult & CheckProductResult;
interface UsageParams {
    customer_id: string;
    feature_id: string;
    value: number;
    customer_data?: CustomerData;
}
interface UsageResult {
    code: string;
    customer_id: string;
    feature_id: string;
}
interface SetupPaymentParams {
    customer_id: string;
    success_url?: string;
    checkout_session_params?: Record<string, any>;
}
interface SetupPaymentResult {
    customer_id: string;
    url: string;
}

declare const AttachFeatureOptionsSchema: z.ZodObject<{
    feature_id: z.ZodString;
    quantity: z.ZodNumber;
}, z.core.$strip>;
type AttachFeatureOptions = z.infer<typeof AttachFeatureOptionsSchema>;
declare const AttachParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    product_id: z.ZodOptional<z.ZodString>;
    entity_id: z.ZodOptional<z.ZodString>;
    options: z.ZodOptional<z.ZodArray<z.ZodObject<{
        feature_id: z.ZodString;
        quantity: z.ZodNumber;
    }, z.core.$strip>>>;
    product_ids: z.ZodOptional<z.ZodArray<z.ZodString>>;
    free_trial: z.ZodOptional<z.ZodBoolean>;
    success_url: z.ZodOptional<z.ZodString>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    force_checkout: z.ZodOptional<z.ZodBoolean>;
    customer_data: z.ZodOptional<z.ZodObject<{
        name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        email: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        fingerprint: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    }, z.core.$strip>>;
    entity_data: z.ZodOptional<z.ZodAny>;
    checkout_session_params: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    reward: z.ZodOptional<z.ZodString>;
    invoice: z.ZodOptional<z.ZodBoolean>;
    new_billing_subscription: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
type AttachParams = z.infer<typeof AttachParamsSchema>;
declare const CheckoutParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    product_id: z.ZodString;
    product_ids: z.ZodOptional<z.ZodArray<z.ZodString>>;
    entity_id: z.ZodOptional<z.ZodString>;
    options: z.ZodOptional<z.ZodArray<z.ZodObject<{
        feature_id: z.ZodString;
        quantity: z.ZodNumber;
    }, z.core.$strip>>>;
    force_checkout: z.ZodOptional<z.ZodBoolean>;
    invoice: z.ZodOptional<z.ZodBoolean>;
    success_url: z.ZodOptional<z.ZodString>;
    customer_data: z.ZodOptional<z.ZodObject<{
        name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        email: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        fingerprint: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    }, z.core.$strip>>;
    entity_data: z.ZodOptional<z.ZodAny>;
    checkout_session_params: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    reward: z.ZodOptional<z.ZodString>;
    new_billing_subscription: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
type CheckoutParams = z.infer<typeof CheckoutParamsSchema>;
type CheckoutResult = {
    url?: string;
    customer_id: string;
    has_prorations: boolean;
    lines: {
        description: string;
        amount: number;
        item: ProductItem;
    }[];
    total: number;
    currency: string;
    options: AttachFeatureOptions[];
    product: Product;
    current_product: Product;
    free_trial?: boolean;
    next_cycle?: {
        starts_at: number;
        total: number;
    };
};

declare const QueryParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    feature_id: z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString>]>;
    range: z.ZodOptional<z.ZodEnum<{
        "24h": "24h";
        "7d": "7d";
        "30d": "30d";
        "90d": "90d";
        last_cycle: "last_cycle";
        "1bc": "1bc";
        "3bc": "3bc";
    }>>;
    group_by: z.ZodOptional<z.ZodString>;
    bin_size: z.ZodOptional<z.ZodEnum<{
        day: "day";
        hour: "hour";
    }>>;
    custom_range: z.ZodOptional<z.ZodObject<{
        start: z.ZodNumber;
        end: z.ZodNumber;
    }, z.core.$strip>>;
}, z.core.$strip>;
type QueryParams = z.infer<typeof QueryParamsSchema>;
type QueryResult = {
    list: Array<{
        period: number;
    } & {
        [key: string]: number | Record<string, number>;
    }>;
};
declare const EventsListParamsSchema: z.ZodObject<{
    offset: z.ZodDefault<z.ZodCoercedNumber<unknown>>;
    limit: z.ZodDefault<z.ZodCoercedNumber<unknown>>;
    customer_id: z.ZodString;
    feature_id: z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString>]>;
    custom_range: z.ZodOptional<z.ZodObject<{
        start: z.ZodOptional<z.ZodCoercedNumber<unknown>>;
        end: z.ZodOptional<z.ZodCoercedNumber<unknown>>;
    }, z.core.$strip>>;
}, z.core.$strip>;
type EventsListParams = z.infer<typeof EventsListParamsSchema>;

declare enum FeatureType {
    Boolean = "boolean",
    SingleUse = "single_use",
    ContinuousUse = "continuous_use",
    CreditSystem = "credit_system"
}
declare const FeatureSchema: z.ZodObject<{
    id: z.ZodString;
    name: z.ZodString;
    type: z.ZodEnum<typeof FeatureType>;
    display: z.ZodOptional<z.ZodNullable<z.ZodObject<{
        singular: z.ZodString;
        plural: z.ZodString;
    }, z.core.$strip>>>;
    credit_schema: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodObject<{
        metered_feature_id: z.ZodString;
        credit_cost: z.ZodNumber;
    }, z.core.$strip>>>>;
    archived: z.ZodBoolean;
}, z.core.$strip>;
type Feature = z.infer<typeof FeatureSchema>;

declare class Autumn {
    private readonly secretKey;
    private readonly publishableKey;
    private headers;
    private url;
    private logger;
    readonly defaultReturnUrl?: string;
    constructor(options?: {
        secretKey?: string;
        publishableKey?: string;
        url?: string;
        version?: string;
        headers?: Record<string, string>;
        logLevel?: string;
        defaultReturnUrl?: string;
    });
    get(path: string): Promise<Result<any, AutumnError>>;
    post(path: string, body: any): Promise<Result<any, AutumnError>>;
    delete(path: string): Promise<Result<any, AutumnError>>;
    static customers: {
        list: (params?: ListCustomersParams) => Promise<Result<{
            list: Customer[];
            total: number;
            limit: number;
            offset: number;
        }, AutumnError>>;
        get: <const T extends readonly CustomerExpandOption[] = readonly []>(id: string, params?: GetCustomerParams<T>) => AutumnPromise<ExpandedCustomer<T>>;
        create: <const T extends readonly CustomerExpandOption[] = readonly []>(params?: CreateCustomerParams<T>) => AutumnPromise<ExpandedCustomer<T>>;
        update: (id: string, params: UpdateCustomerParams) => Promise<Result<Customer, AutumnError>>;
        delete: (id: string, params?: DeleteCustomerParams) => Promise<Result<Customer, AutumnError>>;
        billingPortal: (id: string, params?: BillingPortalParams) => Promise<Result<BillingPortalResult, AutumnError>>;
        updateBalances: (id: string, params: UpdateBalancesParams) => Promise<Result<UpdateBalancesResult, AutumnError>>;
    };
    static products: {
        get: (id: string) => Promise<Result<Product, AutumnError>>;
        create: (params?: CreateProductParams) => Promise<Result<Product, AutumnError>>;
        list: (params?: ListProductsParams) => Promise<Result<{
            list: Product[];
        }, AutumnError>>;
        delete: (id: string) => Promise<Result<{
            success: boolean;
        }, AutumnError>>;
    };
    static entities: {
        get: (customer_id: string, entity_id: string, params?: GetEntityParams) => Promise<Result<Entity, AutumnError>>;
        create: (customer_id: string, params?: CreateEntityParams | CreateEntityParams[]) => Promise<Result<CreateEntityResult, AutumnError>>;
        transfer: (customer_id: string, params: TransferProductParams) => Promise<Result<TransferProductResult, AutumnError>>;
        delete: (customer_id: string, entity_id: string) => Promise<Result<DeleteEntityResult, AutumnError>>;
    };
    static referrals: {
        createCode: (params: CreateReferralCodeParams) => Promise<Result<CreateReferralCodeResult, AutumnError>>;
        redeemCode: (params: RedeemReferralCodeParams) => Promise<Result<RedeemReferralCodeResult, AutumnError>>;
    };
    static features: {
        list: () => Promise<Result<{
            list: Feature[];
        }, AutumnError>>;
        get: (id: string) => Promise<Result<{
            id: string;
            name: string;
            type: FeatureType;
            archived: boolean;
            display?: {
                singular: string;
                plural: string;
            } | null | undefined;
            credit_schema?: {
                metered_feature_id: string;
                credit_cost: number;
            }[] | null | undefined;
        }, AutumnError>>;
    };
    static events: {
        list: (params: EventsListParams) => Promise<Result<{
            list: {
                id: string;
                timestamp: number;
                feature_id: string;
                customer_id: string;
                value: number;
                properties: Record<string, never>;
            }[];
            has_more: boolean;
            offset: number;
            limit: number;
            total: number;
        }, AutumnError>>;
        aggregate: (params: QueryParams) => Promise<Result<QueryResult, AutumnError>>;
    };
    static balances: {
        create: (params: CreateBalanceParams) => Promise<Result<CreateBalanceResponse, AutumnError>>;
    };
    customers: {
        list: (params?: ListCustomersParams) => Promise<Result<{
            list: Customer[];
            total: number;
            limit: number;
            offset: number;
        }, AutumnError>>;
        get: <const T extends readonly CustomerExpandOption[] = readonly []>(id: string, params?: GetCustomerParams<T>) => AutumnPromise<ExpandedCustomer<T>>;
        create: <const T extends readonly CustomerExpandOption[] = readonly []>(params?: CreateCustomerParams<T>) => AutumnPromise<ExpandedCustomer<T>>;
        update: (id: string, params: UpdateCustomerParams) => Promise<Result<Customer, AutumnError>>;
        delete: (id: string, params?: DeleteCustomerParams) => Promise<Result<Customer, AutumnError>>;
        billingPortal: (id: string, params?: BillingPortalParams) => Promise<Result<BillingPortalResult, AutumnError>>;
        updateBalances: (id: string, params: UpdateBalancesParams) => Promise<Result<UpdateBalancesResult, AutumnError>>;
    };
    products: {
        get: (id: string) => Promise<Result<Product, AutumnError>>;
        create: (params?: CreateProductParams) => Promise<Result<Product, AutumnError>>;
        list: (params?: ListProductsParams) => Promise<Result<{
            list: Product[];
        }, AutumnError>>;
        delete: (id: string) => Promise<Result<{
            success: boolean;
        }, AutumnError>>;
    };
    entities: {
        get: (customer_id: string, entity_id: string, params?: GetEntityParams) => Promise<Result<Entity, AutumnError>>;
        create: (customer_id: string, params?: CreateEntityParams | CreateEntityParams[]) => Promise<Result<CreateEntityResult, AutumnError>>;
        transfer: (customer_id: string, params: TransferProductParams) => Promise<Result<TransferProductResult, AutumnError>>;
        delete: (customer_id: string, entity_id: string) => Promise<Result<DeleteEntityResult, AutumnError>>;
    };
    referrals: {
        createCode: (params: CreateReferralCodeParams) => Promise<Result<CreateReferralCodeResult, AutumnError>>;
        redeemCode: (params: RedeemReferralCodeParams) => Promise<Result<RedeemReferralCodeResult, AutumnError>>;
    };
    features: {
        list: () => Promise<Result<{
            list: Feature[];
        }, AutumnError>>;
        get: (id: string) => Promise<Result<{
            id: string;
            name: string;
            type: FeatureType;
            archived: boolean;
            display?: {
                singular: string;
                plural: string;
            } | null | undefined;
            credit_schema?: {
                metered_feature_id: string;
                credit_cost: number;
            }[] | null | undefined;
        }, AutumnError>>;
    };
    events: {
        list: (params: EventsListParams) => Promise<Result<{
            list: {
                id: string;
                timestamp: number;
                feature_id: string;
                customer_id: string;
                value: number;
                properties: Record<string, never>;
            }[];
            has_more: boolean;
            offset: number;
            limit: number;
            total: number;
        }, AutumnError>>;
        aggregate: (params: QueryParams) => Promise<Result<QueryResult, AutumnError>>;
    };
    balances: {
        create: (params: CreateBalanceParams) => Promise<Result<CreateBalanceResponse, AutumnError>>;
    };
    /**
     * Initiates a checkout flow for a product purchase.
     *
     * The checkout function handles the purchase process for products with pricing.
     * It determines whether to show a dialog for user input or redirect directly
     * to Stripe based on the customer's state and product requirements.
     *
     * @param params - Checkout parameters including product ID, customer data, and options
     * @returns Promise resolving to checkout details including pricing, prorations, and URLs
     *
     * @example
     * ```typescript
     * const result = await autumn.checkout({
     *   customer_id: "user_123",
     *   product_id: "pro",
     *   success_url: "https://myapp.com/success"
     * });
     *
     * if (result.url) {
     *   // Redirect to Stripe checkout
     *   window.location.href = result.url;
     * }
     * ```
     */
    checkout(params: CheckoutParams): Promise<Result<CheckoutResult, AutumnError>>;
    static checkout: (params: CheckoutParams) => Promise<Result<CheckoutResult, AutumnError>>;
    static usage: (params: UsageParams) => Promise<Result<UsageResult, AutumnError>>;
    /**
     * Attaches a product to a customer, enabling access and handling billing.
     *
     * The attach function activates a product for a customer and applies all product items.
     * When you attach a product:
     * - The customer gains access to all features in the product
     * - If the product has prices, the customer will be billed accordingly
     * - If there's no existing payment method, a checkout URL will be generated
     *
     * @param params - Attach parameters including customer ID, product ID, and options
     * @returns Promise resolving to attachment result with checkout URL if needed
     *
     * @example
     * ```typescript
     * const result = await autumn.attach({
     *   customer_id: "user_123",
     *   product_id: "pro",
     *   success_url: "https://myapp.com/success"
     * });
     *
     * if (result.checkout_url) {
     *   // Payment required - redirect to checkout
     *   window.location.href = result.checkout_url;
     * } else {
     *   // Product successfully attached
     *   console.log("Access granted:", result.message);
     * }
     * ```
     */
    attach(params: AttachParams): Promise<Result<{
        customer_id: string;
        product_ids: string[];
        code: string;
        message: string;
        checkout_url?: string | undefined;
        customer_data?: any;
        invoice?: {
            status: string;
            stripe_id: string;
            hosted_invoice_url: string | null;
            total: number;
            currency: string;
        } | undefined;
    }, AutumnError>>;
    static attach: (params: AttachParams) => Promise<Result<{
        customer_id: string;
        product_ids: string[];
        code: string;
        message: string;
        checkout_url?: string | undefined;
        customer_data?: any;
        invoice?: {
            status: string;
            stripe_id: string;
            hosted_invoice_url: string | null;
            total: number;
            currency: string;
        } | undefined;
    }, AutumnError>>;
    static setupPayment: (params: SetupPaymentParams) => Promise<Result<SetupPaymentResult, AutumnError>>;
    /**
     * Sets up a payment method for a customer.
     *
     * This method allows you to set up payment methods for customers without
     * immediately charging them. Useful for collecting payment information
     * before product attachment or for updating existing payment methods.
     *
     * @param params - Setup payment parameters including customer information
     * @returns Promise resolving to setup payment result
     *
     * @example
     * ```typescript
     * const result = await autumn.setupPayment({
     *   customer_id: "user_123"
     * });
     * ```
     */
    setupPayment(params: SetupPaymentParams): Promise<Result<SetupPaymentResult, AutumnError>>;
    static cancel: (params: CancelParams) => Promise<Result<{
        success: boolean;
        customer_id: string;
        product_id: string;
    }, AutumnError>>;
    /**
     * Cancels a customer's subscription or product attachment.
     *
     * This method allows you to cancel a customer's subscription to a specific product.
     * You can choose to cancel immediately or at the end of the billing cycle.
     *
     * @param params - Cancel parameters including customer ID and product ID
     * @returns Promise resolving to cancellation result
     *
     * @example
     * ```typescript
     * const result = await autumn.cancel({
     *   customer_id: "user_123",
     *   product_id: "pro",
     *   cancel_immediately: false // Cancel at end of billing cycle
     * });
     * ```
     */
    cancel(params: CancelParams): Promise<Result<{
        success: boolean;
        customer_id: string;
        product_id: string;
    }, AutumnError>>;
    static check: (params: CheckParams) => Promise<Result<CheckResult, AutumnError>>;
    /**
     * Checks if a customer has access to a specific feature.
     *
     * This method verifies whether a customer has permission to use a feature
     * and checks their remaining balance/usage limits. It can be used to gate
     * features and determine when to show upgrade prompts.
     *
     * @param params - Check parameters including customer ID and feature ID
     * @returns Promise resolving to access check result with allowed status and balance info
     *
     * @example
     * ```typescript
     * const result = await autumn.check({
     *   customer_id: "user_123",
     *   feature_id: "messages",
     *   required_balance: 1
     * });
     *
     * if (!result.allowed) {
     *   console.log("Feature access denied - upgrade required");
     * }
     * ```
     */
    check(params: CheckParams): Promise<Result<CheckResult, AutumnError>>;
    static track: (params: TrackParams) => Promise<Result<{
        id: string;
        code: string;
        customer_id: string;
        feature_id?: string | undefined;
        event_name?: string | undefined;
    }, AutumnError>>;
    /**
     * Tracks usage events for features or analytics.
     *
     * This method records usage events for metered features, updating the customer's
     * balance and usage statistics. It's typically used server-side to ensure
     * accurate tracking that cannot be manipulated by users.
     *
     * @param params - Track parameters including customer ID, feature ID, and usage value
     * @returns Promise resolving to tracking result
     *
     * @example
     * ```typescript
     * const result = await autumn.track({
     *   customer_id: "user_123",
     *   feature_id: "messages",
     *   value: 1 // Track 1 message sent
     * });
     * ```
     */
    track(params: TrackParams): Promise<Result<{
        id: string;
        code: string;
        customer_id: string;
        feature_id?: string | undefined;
        event_name?: string | undefined;
    }, AutumnError>>;
    /**
     * Retrieves usage statistics and analytics for a customer.
     *
     * This method fetches detailed usage information for a customer's features,
     * including current balances, usage history, and analytics data. Useful
     * for displaying usage dashboards or generating reports.
     *
     * @param params - Usage parameters including customer ID and optional filters
     * @returns Promise resolving to usage statistics and analytics data
     *
     * @example
     * ```typescript
     * const result = await autumn.usage({
     *   customer_id: "user_123",
     *   feature_id: "messages"
     *   value: 20 // Usage value
     * });
     * ```
     */
    usage(params: UsageParams): Promise<Result<UsageResult, AutumnError>>;
    static query: (params: QueryParams) => Promise<Result<QueryResult, AutumnError>>;
    /**
     * Performs advanced queries on customer data and analytics.
     *
     * This method allows you to run complex queries against customer data,
     * usage patterns, and billing information. Useful for generating reports,
     * analytics, and custom data insights.
     *
     * @param params - Query parameters including customer ID and query specifications
     * @returns Promise resolving to query results with requested data
     *
     * @example
     * ```typescript
     * const result = await autumn.query({
     *   customer_id: "user_123",
     *   feature_id: "messages" // feature id to fetch for query, can also be an array
     * });
     *
     * ```
     */
    query(params: QueryParams): Promise<Result<QueryResult, AutumnError>>;
}

declare const CreateReferralCodeParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    program_id: z.ZodString;
}, z.core.$strip>;
type CreateReferralCodeParams = z.infer<typeof CreateReferralCodeParamsSchema>;
interface CreateReferralCodeResult {
    code: string;
    customer_id: string;
    created_at: number;
}
declare const RedeemReferralCodeParamsSchema: z.ZodObject<{
    code: z.ZodString;
    customer_id: z.ZodString;
}, z.core.$strip>;
type RedeemReferralCodeParams = z.infer<typeof RedeemReferralCodeParamsSchema>;
interface RedeemReferralCodeResult {
    id: string;
    customer_id: string;
    reward_id: string;
    referrer: {
        id: string;
        name: string | null;
        email: string | null;
    };
}

declare const CreateBalanceParamsSchema: z.ZodObject<{
    feature_id: z.ZodString;
    customer_id: z.ZodString;
    entity_id: z.ZodOptional<z.ZodString>;
    granted_balance: z.ZodOptional<z.ZodNumber>;
    unlimited: z.ZodOptional<z.ZodBoolean>;
    reset: z.ZodOptional<z.ZodObject<{
        interval: z.ZodEnum<{
            day: "day";
            minute: "minute";
            hour: "hour";
            week: "week";
            month: "month";
            quarter: "quarter";
            semi_annual: "semi_annual";
            year: "year";
            one_off: "one_off";
        }>;
        interval_count: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    expires_at: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
type CreateBalanceParams = z.infer<typeof CreateBalanceParamsSchema>;
type CreateBalanceResponse = {
    message: string;
};

export { Autumn as A, type CustomerData as C };
