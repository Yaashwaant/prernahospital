import { C as CustomerData, a as CheckFeatureResult, b as CheckProductResult, P as ProductItem, c as Product, L as ListCustomersParams, d as Customer, e as CustomerExpandOption, G as GetCustomerParams, E as ExpandedCustomer, f as CreateCustomerParams, U as UpdateCustomerParams, D as DeleteCustomerParams, B as BillingPortalParams, g as BillingPortalResult, h as UpdateBalancesParams, i as UpdateBalancesResult, j as CreateProductParams, k as ListProductsParams, l as GetEntityParams$1, m as Entity, n as CreateEntityParams$1, o as CreateEntityResult, T as TransferProductParams, p as TransferProductResult, q as DeleteEntityResult } from './cusTypes-CmsDQqVo.mjs';
import { z } from 'zod/v4';
import { R as Result, A as AutumnError, a as AutumnPromise } from './response-Bal_cFRb.mjs';

declare const CancelParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    product_id: z.ZodString;
    entity_id: z.ZodOptional<z.ZodString>;
    cancel_immediately: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
type CancelParams = z.infer<typeof CancelParamsSchema>;
declare const TrackParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    value: z.ZodOptional<z.ZodNumber>;
    feature_id: z.ZodOptional<z.ZodString>;
    event_name: z.ZodOptional<z.ZodString>;
    entity_id: z.ZodOptional<z.ZodString>;
    customer_data: z.ZodOptional<z.ZodAny>;
    idempotency_key: z.ZodOptional<z.ZodString>;
    entity_data: z.ZodOptional<z.ZodAny>;
    properties: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
}, z.core.$strip>;
type TrackParams = z.infer<typeof TrackParamsSchema>;
declare const CheckParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    feature_id: z.ZodOptional<z.ZodString>;
    product_id: z.ZodOptional<z.ZodString>;
    entity_id: z.ZodOptional<z.ZodString>;
    customer_data: z.ZodOptional<z.ZodAny>;
    required_balance: z.ZodOptional<z.ZodNumber>;
    send_event: z.ZodOptional<z.ZodBoolean>;
    with_preview: z.ZodOptional<z.ZodBoolean>;
    entity_data: z.ZodOptional<z.ZodObject<{
        name: z.ZodOptional<z.ZodString>;
        feature_id: z.ZodString;
    }, z.core.$strip>>;
}, z.core.$strip>;
type CheckParams = z.infer<typeof CheckParamsSchema>;
type CheckResult = CheckFeatureResult & CheckProductResult;
interface UsageParams {
    customer_id: string;
    feature_id: string;
    value: number;
    customer_data?: CustomerData;
}
interface UsageResult {
    code: string;
    customer_id: string;
    feature_id: string;
}
interface SetupPaymentParams {
    customer_id: string;
    success_url?: string;
    checkout_session_params?: Record<string, any>;
}
interface SetupPaymentResult {
    customer_id: string;
    url: string;
}

declare const AttachFeatureOptionsSchema: z.ZodObject<{
    feature_id: z.ZodString;
    quantity: z.ZodNumber;
}, z.core.$strip>;
type AttachFeatureOptions = z.infer<typeof AttachFeatureOptionsSchema>;
declare const AttachParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    product_id: z.ZodOptional<z.ZodString>;
    entity_id: z.ZodOptional<z.ZodString>;
    options: z.ZodOptional<z.ZodArray<z.ZodObject<{
        feature_id: z.ZodString;
        quantity: z.ZodNumber;
    }, z.core.$strip>>>;
    product_ids: z.ZodOptional<z.ZodArray<z.ZodString>>;
    free_trial: z.ZodOptional<z.ZodBoolean>;
    success_url: z.ZodOptional<z.ZodString>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    force_checkout: z.ZodOptional<z.ZodBoolean>;
    customer_data: z.ZodOptional<z.ZodObject<{
        name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        email: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        fingerprint: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    }, z.core.$strip>>;
    entity_data: z.ZodOptional<z.ZodAny>;
    checkout_session_params: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    reward: z.ZodOptional<z.ZodString>;
    invoice: z.ZodOptional<z.ZodBoolean>;
    new_billing_subscription: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
type AttachParams = z.infer<typeof AttachParamsSchema>;
declare const CheckoutParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    product_id: z.ZodString;
    product_ids: z.ZodOptional<z.ZodArray<z.ZodString>>;
    entity_id: z.ZodOptional<z.ZodString>;
    options: z.ZodOptional<z.ZodArray<z.ZodObject<{
        feature_id: z.ZodString;
        quantity: z.ZodNumber;
    }, z.core.$strip>>>;
    force_checkout: z.ZodOptional<z.ZodBoolean>;
    invoice: z.ZodOptional<z.ZodBoolean>;
    success_url: z.ZodOptional<z.ZodString>;
    customer_data: z.ZodOptional<z.ZodObject<{
        name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        email: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        fingerprint: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    }, z.core.$strip>>;
    entity_data: z.ZodOptional<z.ZodAny>;
    checkout_session_params: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    reward: z.ZodOptional<z.ZodString>;
    new_billing_subscription: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
type CheckoutParams = z.infer<typeof CheckoutParamsSchema>;
type CheckoutResult = {
    url?: string;
    customer_id: string;
    has_prorations: boolean;
    lines: {
        description: string;
        amount: number;
        item: ProductItem;
    }[];
    total: number;
    currency: string;
    options: AttachFeatureOptions[];
    product: Product;
    current_product: Product;
    free_trial?: boolean;
    next_cycle?: {
        starts_at: number;
        total: number;
    };
};

declare const QueryParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    feature_id: z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString>]>;
    range: z.ZodOptional<z.ZodEnum<{
        "24h": "24h";
        "7d": "7d";
        "30d": "30d";
        "90d": "90d";
        last_cycle: "last_cycle";
        "1bc": "1bc";
        "3bc": "3bc";
    }>>;
    group_by: z.ZodOptional<z.ZodString>;
    bin_size: z.ZodOptional<z.ZodEnum<{
        day: "day";
        hour: "hour";
    }>>;
    custom_range: z.ZodOptional<z.ZodObject<{
        start: z.ZodNumber;
        end: z.ZodNumber;
    }, z.core.$strip>>;
}, z.core.$strip>;
type QueryParams = z.infer<typeof QueryParamsSchema>;
type QueryResult = {
    list: Array<{
        period: number;
    } & {
        [key: string]: number | Record<string, number>;
    }>;
};
declare const EventsListParamsSchema: z.ZodObject<{
    offset: z.ZodDefault<z.ZodCoercedNumber<unknown>>;
    limit: z.ZodDefault<z.ZodCoercedNumber<unknown>>;
    customer_id: z.ZodString;
    feature_id: z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString>]>;
    custom_range: z.ZodOptional<z.ZodObject<{
        start: z.ZodOptional<z.ZodCoercedNumber<unknown>>;
        end: z.ZodOptional<z.ZodCoercedNumber<unknown>>;
    }, z.core.$strip>>;
}, z.core.$strip>;
type EventsListParams = z.infer<typeof EventsListParamsSchema>;

declare enum FeatureType {
    Boolean = "boolean",
    SingleUse = "single_use",
    ContinuousUse = "continuous_use",
    CreditSystem = "credit_system"
}
declare const FeatureSchema: z.ZodObject<{
    id: z.ZodString;
    name: z.ZodString;
    type: z.ZodEnum<typeof FeatureType>;
    display: z.ZodOptional<z.ZodNullable<z.ZodObject<{
        singular: z.ZodString;
        plural: z.ZodString;
    }, z.core.$strip>>>;
    credit_schema: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodObject<{
        metered_feature_id: z.ZodString;
        credit_cost: z.ZodNumber;
    }, z.core.$strip>>>>;
    archived: z.ZodBoolean;
}, z.core.$strip>;
type Feature = z.infer<typeof FeatureSchema>;

declare class Autumn {
    private readonly secretKey;
    private readonly publishableKey;
    private headers;
    private url;
    private logger;
    readonly defaultReturnUrl?: string;
    constructor(options?: {
        secretKey?: string;
        publishableKey?: string;
        url?: string;
        version?: string;
        headers?: Record<string, string>;
        logLevel?: string;
        defaultReturnUrl?: string;
    });
    get(path: string): Promise<Result<any, AutumnError>>;
    post(path: string, body: any): Promise<Result<any, AutumnError>>;
    delete(path: string): Promise<Result<any, AutumnError>>;
    static customers: {
        list: (params?: ListCustomersParams) => Promise<Result<{
            list: Customer[];
            total: number;
            limit: number;
            offset: number;
        }, AutumnError>>;
        get: <const T extends readonly CustomerExpandOption[] = readonly []>(id: string, params?: GetCustomerParams<T>) => AutumnPromise<ExpandedCustomer<T>>;
        create: <const T extends readonly CustomerExpandOption[] = readonly []>(params?: CreateCustomerParams<T>) => AutumnPromise<ExpandedCustomer<T>>;
        update: (id: string, params: UpdateCustomerParams) => Promise<Result<Customer, AutumnError>>;
        delete: (id: string, params?: DeleteCustomerParams) => Promise<Result<Customer, AutumnError>>;
        billingPortal: (id: string, params?: BillingPortalParams) => Promise<Result<BillingPortalResult, AutumnError>>;
        updateBalances: (id: string, params: UpdateBalancesParams) => Promise<Result<UpdateBalancesResult, AutumnError>>;
    };
    static products: {
        get: (id: string) => Promise<Result<Product, AutumnError>>;
        create: (params?: CreateProductParams) => Promise<Result<Product, AutumnError>>;
        list: (params?: ListProductsParams) => Promise<Result<{
            list: Product[];
        }, AutumnError>>;
        delete: (id: string) => Promise<Result<{
            success: boolean;
        }, AutumnError>>;
    };
    static entities: {
        get: (customer_id: string, entity_id: string, params?: GetEntityParams$1) => Promise<Result<Entity, AutumnError>>;
        create: (customer_id: string, params?: CreateEntityParams$1 | CreateEntityParams$1[]) => Promise<Result<CreateEntityResult, AutumnError>>;
        transfer: (customer_id: string, params: TransferProductParams) => Promise<Result<TransferProductResult, AutumnError>>;
        delete: (customer_id: string, entity_id: string) => Promise<Result<DeleteEntityResult, AutumnError>>;
    };
    static referrals: {
        createCode: (params: CreateReferralCodeParams) => Promise<Result<CreateReferralCodeResult, AutumnError>>;
        redeemCode: (params: RedeemReferralCodeParams) => Promise<Result<RedeemReferralCodeResult, AutumnError>>;
    };
    static features: {
        list: () => Promise<Result<{
            list: Feature[];
        }, AutumnError>>;
        get: (id: string) => Promise<Result<{
            id: string;
            name: string;
            type: FeatureType;
            archived: boolean;
            display?: {
                singular: string;
                plural: string;
            } | null | undefined;
            credit_schema?: {
                metered_feature_id: string;
                credit_cost: number;
            }[] | null | undefined;
        }, AutumnError>>;
    };
    static events: {
        list: (params: EventsListParams) => Promise<Result<{
            list: {
                id: string;
                timestamp: number;
                feature_id: string;
                customer_id: string;
                value: number;
                properties: Record<string, never>;
            }[];
            has_more: boolean;
            offset: number;
            limit: number;
            total: number;
        }, AutumnError>>;
        aggregate: (params: QueryParams) => Promise<Result<QueryResult, AutumnError>>;
    };
    static balances: {
        create: (params: CreateBalanceParams) => Promise<Result<CreateBalanceResponse, AutumnError>>;
    };
    customers: {
        list: (params?: ListCustomersParams) => Promise<Result<{
            list: Customer[];
            total: number;
            limit: number;
            offset: number;
        }, AutumnError>>;
        get: <const T extends readonly CustomerExpandOption[] = readonly []>(id: string, params?: GetCustomerParams<T>) => AutumnPromise<ExpandedCustomer<T>>;
        create: <const T extends readonly CustomerExpandOption[] = readonly []>(params?: CreateCustomerParams<T>) => AutumnPromise<ExpandedCustomer<T>>;
        update: (id: string, params: UpdateCustomerParams) => Promise<Result<Customer, AutumnError>>;
        delete: (id: string, params?: DeleteCustomerParams) => Promise<Result<Customer, AutumnError>>;
        billingPortal: (id: string, params?: BillingPortalParams) => Promise<Result<BillingPortalResult, AutumnError>>;
        updateBalances: (id: string, params: UpdateBalancesParams) => Promise<Result<UpdateBalancesResult, AutumnError>>;
    };
    products: {
        get: (id: string) => Promise<Result<Product, AutumnError>>;
        create: (params?: CreateProductParams) => Promise<Result<Product, AutumnError>>;
        list: (params?: ListProductsParams) => Promise<Result<{
            list: Product[];
        }, AutumnError>>;
        delete: (id: string) => Promise<Result<{
            success: boolean;
        }, AutumnError>>;
    };
    entities: {
        get: (customer_id: string, entity_id: string, params?: GetEntityParams$1) => Promise<Result<Entity, AutumnError>>;
        create: (customer_id: string, params?: CreateEntityParams$1 | CreateEntityParams$1[]) => Promise<Result<CreateEntityResult, AutumnError>>;
        transfer: (customer_id: string, params: TransferProductParams) => Promise<Result<TransferProductResult, AutumnError>>;
        delete: (customer_id: string, entity_id: string) => Promise<Result<DeleteEntityResult, AutumnError>>;
    };
    referrals: {
        createCode: (params: CreateReferralCodeParams) => Promise<Result<CreateReferralCodeResult, AutumnError>>;
        redeemCode: (params: RedeemReferralCodeParams) => Promise<Result<RedeemReferralCodeResult, AutumnError>>;
    };
    features: {
        list: () => Promise<Result<{
            list: Feature[];
        }, AutumnError>>;
        get: (id: string) => Promise<Result<{
            id: string;
            name: string;
            type: FeatureType;
            archived: boolean;
            display?: {
                singular: string;
                plural: string;
            } | null | undefined;
            credit_schema?: {
                metered_feature_id: string;
                credit_cost: number;
            }[] | null | undefined;
        }, AutumnError>>;
    };
    events: {
        list: (params: EventsListParams) => Promise<Result<{
            list: {
                id: string;
                timestamp: number;
                feature_id: string;
                customer_id: string;
                value: number;
                properties: Record<string, never>;
            }[];
            has_more: boolean;
            offset: number;
            limit: number;
            total: number;
        }, AutumnError>>;
        aggregate: (params: QueryParams) => Promise<Result<QueryResult, AutumnError>>;
    };
    balances: {
        create: (params: CreateBalanceParams) => Promise<Result<CreateBalanceResponse, AutumnError>>;
    };
    /**
     * Initiates a checkout flow for a product purchase.
     *
     * The checkout function handles the purchase process for products with pricing.
     * It determines whether to show a dialog for user input or redirect directly
     * to Stripe based on the customer's state and product requirements.
     *
     * @param params - Checkout parameters including product ID, customer data, and options
     * @returns Promise resolving to checkout details including pricing, prorations, and URLs
     *
     * @example
     * ```typescript
     * const result = await autumn.checkout({
     *   customer_id: "user_123",
     *   product_id: "pro",
     *   success_url: "https://myapp.com/success"
     * });
     *
     * if (result.url) {
     *   // Redirect to Stripe checkout
     *   window.location.href = result.url;
     * }
     * ```
     */
    checkout(params: CheckoutParams): Promise<Result<CheckoutResult, AutumnError>>;
    static checkout: (params: CheckoutParams) => Promise<Result<CheckoutResult, AutumnError>>;
    static usage: (params: UsageParams) => Promise<Result<UsageResult, AutumnError>>;
    /**
     * Attaches a product to a customer, enabling access and handling billing.
     *
     * The attach function activates a product for a customer and applies all product items.
     * When you attach a product:
     * - The customer gains access to all features in the product
     * - If the product has prices, the customer will be billed accordingly
     * - If there's no existing payment method, a checkout URL will be generated
     *
     * @param params - Attach parameters including customer ID, product ID, and options
     * @returns Promise resolving to attachment result with checkout URL if needed
     *
     * @example
     * ```typescript
     * const result = await autumn.attach({
     *   customer_id: "user_123",
     *   product_id: "pro",
     *   success_url: "https://myapp.com/success"
     * });
     *
     * if (result.checkout_url) {
     *   // Payment required - redirect to checkout
     *   window.location.href = result.checkout_url;
     * } else {
     *   // Product successfully attached
     *   console.log("Access granted:", result.message);
     * }
     * ```
     */
    attach(params: AttachParams): Promise<Result<{
        customer_id: string;
        product_ids: string[];
        code: string;
        message: string;
        checkout_url?: string | undefined;
        customer_data?: any;
        invoice?: {
            status: string;
            stripe_id: string;
            hosted_invoice_url: string | null;
            total: number;
            currency: string;
        } | undefined;
    }, AutumnError>>;
    static attach: (params: AttachParams) => Promise<Result<{
        customer_id: string;
        product_ids: string[];
        code: string;
        message: string;
        checkout_url?: string | undefined;
        customer_data?: any;
        invoice?: {
            status: string;
            stripe_id: string;
            hosted_invoice_url: string | null;
            total: number;
            currency: string;
        } | undefined;
    }, AutumnError>>;
    static setupPayment: (params: SetupPaymentParams) => Promise<Result<SetupPaymentResult, AutumnError>>;
    /**
     * Sets up a payment method for a customer.
     *
     * This method allows you to set up payment methods for customers without
     * immediately charging them. Useful for collecting payment information
     * before product attachment or for updating existing payment methods.
     *
     * @param params - Setup payment parameters including customer information
     * @returns Promise resolving to setup payment result
     *
     * @example
     * ```typescript
     * const result = await autumn.setupPayment({
     *   customer_id: "user_123"
     * });
     * ```
     */
    setupPayment(params: SetupPaymentParams): Promise<Result<SetupPaymentResult, AutumnError>>;
    static cancel: (params: CancelParams) => Promise<Result<{
        success: boolean;
        customer_id: string;
        product_id: string;
    }, AutumnError>>;
    /**
     * Cancels a customer's subscription or product attachment.
     *
     * This method allows you to cancel a customer's subscription to a specific product.
     * You can choose to cancel immediately or at the end of the billing cycle.
     *
     * @param params - Cancel parameters including customer ID and product ID
     * @returns Promise resolving to cancellation result
     *
     * @example
     * ```typescript
     * const result = await autumn.cancel({
     *   customer_id: "user_123",
     *   product_id: "pro",
     *   cancel_immediately: false // Cancel at end of billing cycle
     * });
     * ```
     */
    cancel(params: CancelParams): Promise<Result<{
        success: boolean;
        customer_id: string;
        product_id: string;
    }, AutumnError>>;
    static check: (params: CheckParams) => Promise<Result<CheckResult, AutumnError>>;
    /**
     * Checks if a customer has access to a specific feature.
     *
     * This method verifies whether a customer has permission to use a feature
     * and checks their remaining balance/usage limits. It can be used to gate
     * features and determine when to show upgrade prompts.
     *
     * @param params - Check parameters including customer ID and feature ID
     * @returns Promise resolving to access check result with allowed status and balance info
     *
     * @example
     * ```typescript
     * const result = await autumn.check({
     *   customer_id: "user_123",
     *   feature_id: "messages",
     *   required_balance: 1
     * });
     *
     * if (!result.allowed) {
     *   console.log("Feature access denied - upgrade required");
     * }
     * ```
     */
    check(params: CheckParams): Promise<Result<CheckResult, AutumnError>>;
    static track: (params: TrackParams) => Promise<Result<{
        id: string;
        code: string;
        customer_id: string;
        feature_id?: string | undefined;
        event_name?: string | undefined;
    }, AutumnError>>;
    /**
     * Tracks usage events for features or analytics.
     *
     * This method records usage events for metered features, updating the customer's
     * balance and usage statistics. It's typically used server-side to ensure
     * accurate tracking that cannot be manipulated by users.
     *
     * @param params - Track parameters including customer ID, feature ID, and usage value
     * @returns Promise resolving to tracking result
     *
     * @example
     * ```typescript
     * const result = await autumn.track({
     *   customer_id: "user_123",
     *   feature_id: "messages",
     *   value: 1 // Track 1 message sent
     * });
     * ```
     */
    track(params: TrackParams): Promise<Result<{
        id: string;
        code: string;
        customer_id: string;
        feature_id?: string | undefined;
        event_name?: string | undefined;
    }, AutumnError>>;
    /**
     * Retrieves usage statistics and analytics for a customer.
     *
     * This method fetches detailed usage information for a customer's features,
     * including current balances, usage history, and analytics data. Useful
     * for displaying usage dashboards or generating reports.
     *
     * @param params - Usage parameters including customer ID and optional filters
     * @returns Promise resolving to usage statistics and analytics data
     *
     * @example
     * ```typescript
     * const result = await autumn.usage({
     *   customer_id: "user_123",
     *   feature_id: "messages"
     *   value: 20 // Usage value
     * });
     * ```
     */
    usage(params: UsageParams): Promise<Result<UsageResult, AutumnError>>;
    static query: (params: QueryParams) => Promise<Result<QueryResult, AutumnError>>;
    /**
     * Performs advanced queries on customer data and analytics.
     *
     * This method allows you to run complex queries against customer data,
     * usage patterns, and billing information. Useful for generating reports,
     * analytics, and custom data insights.
     *
     * @param params - Query parameters including customer ID and query specifications
     * @returns Promise resolving to query results with requested data
     *
     * @example
     * ```typescript
     * const result = await autumn.query({
     *   customer_id: "user_123",
     *   feature_id: "messages" // feature id to fetch for query, can also be an array
     * });
     *
     * ```
     */
    query(params: QueryParams): Promise<Result<QueryResult, AutumnError>>;
}

declare const CreateReferralCodeParamsSchema: z.ZodObject<{
    customer_id: z.ZodString;
    program_id: z.ZodString;
}, z.core.$strip>;
type CreateReferralCodeParams = z.infer<typeof CreateReferralCodeParamsSchema>;
interface CreateReferralCodeResult {
    code: string;
    customer_id: string;
    created_at: number;
}
declare const RedeemReferralCodeParamsSchema: z.ZodObject<{
    code: z.ZodString;
    customer_id: z.ZodString;
}, z.core.$strip>;
type RedeemReferralCodeParams = z.infer<typeof RedeemReferralCodeParamsSchema>;
interface RedeemReferralCodeResult {
    id: string;
    customer_id: string;
    reward_id: string;
    referrer: {
        id: string;
        name: string | null;
        email: string | null;
    };
}

declare const CreateBalanceParamsSchema: z.ZodObject<{
    feature_id: z.ZodString;
    customer_id: z.ZodString;
    entity_id: z.ZodOptional<z.ZodString>;
    granted_balance: z.ZodOptional<z.ZodNumber>;
    unlimited: z.ZodOptional<z.ZodBoolean>;
    reset: z.ZodOptional<z.ZodObject<{
        interval: z.ZodEnum<{
            day: "day";
            minute: "minute";
            hour: "hour";
            week: "week";
            month: "month";
            quarter: "quarter";
            semi_annual: "semi_annual";
            year: "year";
            one_off: "one_off";
        }>;
        interval_count: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    expires_at: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
type CreateBalanceParams = z.infer<typeof CreateBalanceParamsSchema>;
type CreateBalanceResponse = {
    message: string;
};

declare const CreateEntityParamsSchema: z.ZodObject<{
    id: z.ZodString;
    name: z.ZodOptional<z.ZodString>;
    featureId: z.ZodString;
}, z.core.$strip>;
type CreateEntityParams = z.infer<typeof CreateEntityParamsSchema>;
declare const GetEntityParamsSchema: z.ZodObject<{
    expand: z.ZodOptional<z.ZodArray<z.ZodString>>;
}, z.core.$strip>;
type GetEntityParams = z.infer<typeof GetEntityParamsSchema>;

declare const createAutumnClient: (publishableKey?: string) => Autumn;
declare const createCusAction: (args: Omit<{
    customerId: string;
    customerData?: CustomerData;
    params?: CreateCustomerParams;
}, "customerId"> & {
    encryptedCustomerId?: string;
}, request?: Request) => Promise<any>;
declare const getEntityAction: (args: Omit<{
    customerId: string;
    entityId: string;
    params?: GetEntityParams;
}, "customerId"> & {
    encryptedCustomerId?: string;
}, request?: Request) => Promise<any>;
declare const createEntityAction: (args: Omit<{
    customerId: string;
    entity: CreateEntityParams | CreateEntityParams[];
}, "customerId"> & {
    encryptedCustomerId?: string;
}, request?: Request) => Promise<any>;
declare const deleteEntityAction: (args: Omit<{
    customerId: string;
    entityId: string;
}, "customerId"> & {
    encryptedCustomerId?: string;
}, request?: Request) => Promise<any>;

export { createAutumnClient, createCusAction, createEntityAction, deleteEntityAction, getEntityAction };
