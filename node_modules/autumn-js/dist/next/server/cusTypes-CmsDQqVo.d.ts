import { z } from 'zod/v4';

declare const Infinite = "inf";
declare enum FreeTrialDuration {
    Day = "day"
}
declare enum UsageModel {
    Prepaid = "prepaid",
    PayPerUse = "pay_per_use"
}
type UsageModelType = "prepaid" | "pay_per_use";
declare enum ProductItemInterval {
    Minute = "minute",
    Hour = "hour",
    Day = "day",
    Week = "week",
    Month = "month",
    Quarter = "quarter",
    SemiAnnual = "semi_annual",
    Year = "year",
    Multiple = "multiple"
}
type ProductItemIntervalType = "minute" | "hour" | "day" | "week" | "month" | "quarter" | "semi_annual" | "year" | "multiple";

declare const CheckFeatureResultSchema: z.ZodObject<{
    allowed: z.ZodBoolean;
    feature_id: z.ZodString;
    customer_id: z.ZodString;
    entity_id: z.ZodOptional<z.ZodString>;
    required_balance: z.ZodNumber;
    unlimited: z.ZodOptional<z.ZodBoolean>;
    interval: z.ZodOptional<z.ZodEnum<typeof ProductItemInterval>>;
    balance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    usage: z.ZodOptional<z.ZodNumber>;
    included_usage: z.ZodOptional<z.ZodNumber>;
    next_reset_at: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    overage_allowed: z.ZodOptional<z.ZodBoolean>;
    usage_limit: z.ZodOptional<z.ZodNumber>;
    rollovers: z.ZodOptional<z.ZodObject<{
        balance: z.ZodNumber;
        expires_at: z.ZodNumber;
    }, z.core.$strip>>;
    breakdown: z.ZodOptional<z.ZodArray<z.ZodObject<{
        interval: z.ZodEnum<typeof ProductItemInterval>;
        balance: z.ZodOptional<z.ZodNumber>;
        usage: z.ZodOptional<z.ZodNumber>;
        included_usage: z.ZodOptional<z.ZodNumber>;
        next_reset_at: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>>;
    credit_schema: z.ZodOptional<z.ZodArray<z.ZodObject<{
        feature_id: z.ZodString;
        credit_amount: z.ZodNumber;
    }, z.core.$strip>>>;
}, z.core.$strip>;
type CheckFeatureResult = z.infer<typeof CheckFeatureResultSchema>;
type ProductScenario = "scheduled" | "active" | "new" | "renew" | "upgrade" | "downgrade" | "cancel";
interface CheckProductResult {
    allowed: boolean;
    customer_id: string;
    product_id: string;
    entity_id?: string;
    status?: string;
    preview?: CheckProductPreview;
}
interface CheckProductPreview {
    scenario: ProductScenario;
    product_id: string;
    product_name: string;
    recurring: boolean;
    error_on_attach?: boolean;
    next_cycle_at?: number;
    current_product_name?: string;
    items?: {
        price: string;
        description: string;
        usage_model?: UsageModelType;
    }[];
    options?: {
        feature_id: string;
        feature_name: string;
        billing_units: number;
        price?: number;
        tiers?: {
            to: number | string;
            amount: number;
        }[];
    }[];
    due_today?: {
        price: number;
        currency: string;
    };
    due_next_cycle?: {
        price: number;
        currency: string;
    };
}

declare enum AppEnv {
    Sandbox = "sandbox",
    Live = "live"
}

interface Feature {
    id: string;
    name: string;
    type: "boolean" | "continuous_use" | "single_use" | "credit_system";
}
interface ProductItem {
    type?: "feature" | "priced_feature" | "price";
    feature_id?: string;
    included_usage?: number | typeof Infinite;
    interval?: ProductItemIntervalType;
    feature?: Feature;
    usage_model?: UsageModel;
    price?: number;
    billing_units?: number;
    entity_feature_id?: string;
    reset_usage_when_enabled?: boolean;
    quantity?: number;
    next_cycle_quantity?: number;
    display?: {
        primary_text?: string;
        secondary_text?: string;
    };
}
interface FreeTrial {
    duration: FreeTrialDuration;
    length: number;
    unique_fingerprint: boolean;
    trial_available?: boolean;
}
interface Product {
    id: string;
    created_at: number;
    name: string;
    env: AppEnv;
    is_add_on: boolean;
    is_default: boolean;
    group: string;
    version: number;
    items: ProductItem[];
    free_trial: FreeTrial | null;
    scenario?: ProductScenario;
    base_variant_id: string | null;
    properties: {
        is_free: boolean;
        is_one_off: boolean;
        interval_group: string;
        has_trial: boolean;
        updateable: boolean;
    };
    display?: {
        name?: string;
        description?: string;
        button_text?: string;
        recommend_text?: string;
        everything_from?: string;
        button_url?: string;
    };
}
interface CreateProductParams {
    id: string;
    name?: string;
    is_add_on?: boolean;
    is_default?: boolean;
    items?: ProductItem[];
    free_trial?: FreeTrial;
}
interface ListProductsParams {
    customer_id?: string;
}

declare enum ProductStatus {
    Active = "active",
    Expired = "expired",
    Trialing = "trialing",
    Scheduled = "scheduled",
    PastDue = "past_due"
}
type CustomerExpandOption = "invoices" | "rewards" | "trials_used" | "entities" | "referrals" | "payment_method";

type EntityExpandOption = "invoices";

interface CreateEntityParams {
    id: string;
    name: string;
    feature_id: string;
    customer_data?: CustomerData;
}
interface CreateEntityResult {
    success: boolean;
}
interface DeleteEntityResult {
    success: boolean;
}
interface GetEntityParams {
    expand?: EntityExpandOption[];
}
interface Entity {
    id: string;
    name: string;
    customer_id: string;
    created_at: number;
    env: string;
    products: CustomerProduct[];
    features: Record<string, CustomerFeature>;
    invoices?: CustomerInvoice[];
}
declare const TransferProductParamsSchema: z.ZodObject<{
    from_entity_id: z.ZodString;
    to_entity_id: z.ZodString;
    product_id: z.ZodString;
}, z.core.$strip>;
type TransferProductParams = z.infer<typeof TransferProductParamsSchema>;
type TransferProductResult = {
    success: boolean;
};

declare const CoreCusFeatureSchema: z.ZodObject<{
    unlimited: z.ZodOptional<z.ZodBoolean>;
    interval: z.ZodOptional<z.ZodEnum<typeof ProductItemInterval>>;
    balance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    usage: z.ZodOptional<z.ZodNumber>;
    included_usage: z.ZodOptional<z.ZodNumber>;
    next_reset_at: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    overage_allowed: z.ZodOptional<z.ZodBoolean>;
    usage_limit: z.ZodOptional<z.ZodNumber>;
    rollovers: z.ZodOptional<z.ZodObject<{
        balance: z.ZodNumber;
        expires_at: z.ZodNumber;
    }, z.core.$strip>>;
    breakdown: z.ZodOptional<z.ZodArray<z.ZodObject<{
        interval: z.ZodEnum<typeof ProductItemInterval>;
        balance: z.ZodOptional<z.ZodNumber>;
        usage: z.ZodOptional<z.ZodNumber>;
        included_usage: z.ZodOptional<z.ZodNumber>;
        next_reset_at: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>>;
    credit_schema: z.ZodOptional<z.ZodArray<z.ZodObject<{
        feature_id: z.ZodString;
        credit_amount: z.ZodNumber;
    }, z.core.$strip>>>;
}, z.core.$strip>;
type CoreCustomerFeature = z.infer<typeof CoreCusFeatureSchema>;
interface CustomerFeature extends CoreCustomerFeature {
    id: string;
    name: string;
    type: "static" | "single_use" | "continuous_use";
}
interface CustomerReferral {
    program_id: string;
    customer: {
        id: string;
        name: string | null;
        email: string | null;
    };
    reward_applied: boolean;
    created_at: number;
}
interface CustomerProduct {
    id: string;
    name: string | null;
    group: string | null;
    status: ProductStatus;
    started_at: number;
    canceled_at: number | null;
    version: number;
    subscription_ids?: string[] | null;
    current_period_start?: number | null;
    current_period_end?: number | null;
    trial_ends_at?: number;
    entity_id?: string;
    is_add_on: boolean;
    is_default: boolean;
    items: ProductItem[];
}
interface Customer {
    id: string | null;
    created_at: number;
    name: string | null;
    email: string | null;
    fingerprint: string | null;
    stripe_id: string | null;
    env: AppEnv;
    metadata: Record<string, any>;
    products: CustomerProduct[];
    features: Record<string, CustomerFeature>;
    payment_method?: any;
    referrals?: CustomerReferral[];
}
/**
 * Maps expand option strings to their corresponding types.
 * Used for conditional type expansion based on the expand parameter.
 */
interface CustomerExpandedFields {
    invoices: CustomerInvoice[];
    entities: Entity[];
    referrals: CustomerReferral[];
    rewards: unknown;
    trials_used: unknown;
    payment_method: unknown;
}
/**
 * Utility type that creates a Customer with additional expanded fields
 * based on the expand array passed to the API.
 *
 * @example
 * // Base customer without expanded fields
 * type Base = ExpandedCustomer<[]>;
 *
 * // Customer with invoices and entities expanded
 * type WithExpansion = ExpandedCustomer<['invoices', 'entities']>;
 * // Result: Customer & { invoices: CustomerInvoice[]; entities: Entity[] }
 */
type ExpandedCustomer<T extends readonly CustomerExpandOption[] = readonly []> = Customer & {
    [K in T[number]]: CustomerExpandedFields[K];
};
declare const CustomerDataSchema: z.ZodObject<{
    name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    email: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    fingerprint: z.ZodOptional<z.ZodNullable<z.ZodString>>;
}, z.core.$strip>;
type CustomerData = z.infer<typeof CustomerDataSchema>;
interface GetCustomerParams<T extends readonly CustomerExpandOption[] = readonly []> {
    expand?: T;
}
declare const CreateCustomerParamsSchema: z.ZodObject<{
    id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    email: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    fingerprint: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    expand: z.ZodOptional<z.ZodArray<z.ZodEnum<{
        invoices: "invoices";
        rewards: "rewards";
        trials_used: "trials_used";
        entities: "entities";
        referrals: "referrals";
        payment_method: "payment_method";
    }>>>;
    stripe_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    auto_enable_plan_id: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
type CreateCustomerParamsBase = z.infer<typeof CreateCustomerParamsSchema>;
/**
 * Generic version of CreateCustomerParams that preserves the expand array type
 * for proper ExpandedCustomer inference.
 */
interface CreateCustomerParams<T extends readonly CustomerExpandOption[] = readonly []> extends Omit<CreateCustomerParamsBase, "expand"> {
    expand?: T;
}
interface UpdateCustomerParams {
    id?: string | null;
    name?: string | null;
    email?: string | null;
    fingerprint?: string | null;
    metadata?: Record<string, any>;
    stripe_id?: string;
}
declare const BillingPortalParamsSchema: z.ZodObject<{
    return_url: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
type BillingPortalParams = z.infer<typeof BillingPortalParamsSchema>;
interface BillingPortalResult {
    customer_id: string;
    url: string;
}
interface CustomerInvoice {
    product_ids: string[];
    stripe_id: string;
    status: string;
    total: number;
    currency: string;
    created_at: number;
    hosted_invoice_url: string;
}
declare const UpdateBalancesParamsSchema: z.ZodUnion<[z.ZodUnion<[z.ZodObject<{
    feature_id: z.ZodString;
    balance: z.ZodNumber;
}, z.core.$strip>, z.ZodArray<z.ZodObject<{
    feature_id: z.ZodString;
    balance: z.ZodNumber;
}, z.core.$strip>>]>, z.ZodObject<{
    entity_id: z.ZodOptional<z.ZodString>;
    balances: z.ZodArray<z.ZodObject<{
        feature_id: z.ZodString;
        balance: z.ZodNumber;
    }, z.core.$strip>>;
}, z.core.$strip>]>;
declare const DeleteCustomerParamsSchema: z.ZodObject<{
    delete_in_stripe: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
declare const ListCustomersParamsSchema: z.ZodObject<{
    limit: z.ZodOptional<z.ZodNumber>;
    offset: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
type ListCustomersParams = z.infer<typeof ListCustomersParamsSchema>;
type DeleteCustomerParams = z.infer<typeof DeleteCustomerParamsSchema>;
type UpdateBalancesParams = z.infer<typeof UpdateBalancesParamsSchema>;
type UpdateBalancesResult = {
    success: boolean;
};

export type { BillingPortalParams as B, CustomerData as C, DeleteCustomerParams as D, ExpandedCustomer as E, GetCustomerParams as G, ListCustomersParams as L, ProductItem as P, TransferProductParams as T, UpdateCustomerParams as U, CheckFeatureResult as a, CheckProductResult as b, Product as c, Customer as d, CustomerExpandOption as e, CreateCustomerParams as f, BillingPortalResult as g, UpdateBalancesParams as h, UpdateBalancesResult as i, CreateProductParams as j, ListProductsParams as k, GetEntityParams as l, Entity as m, CreateEntityParams as n, CreateEntityResult as o, TransferProductResult as p, DeleteEntityResult as q };
