import { f as CheckResult, c as SetupPaymentResult, A as AttachParams, C as CancelParams, b as CancelResult, e as CheckParams, T as TrackParams, a as TrackResult, O as OpenBillingPortalParams } from './clientAttachTypes-rRBh7kw-.mjs';
import { C as CheckoutResult, b as CreateReferralCodeResult, R as RedeemReferralCodeResult, A as AttachResult, a as CreateEntityParams, G as GetEntityParams } from './clientEntTypes-jltPLNQ5.mjs';
import { A as AutumnPromise, R as Result } from './response-DKQ_cb7U.mjs';
import { C as CustomerData, b as CustomerExpandOption, d as CreateCustomerParams, c as ExpandedCustomer, B as BillingPortalResult, E as Entity, D as DeleteEntityResult } from './cusTypes-CQtEzl50.mjs';
import { z } from 'zod/v4';
import { A as AutumnError } from './error-DHbclCVh.mjs';
import { P as Product } from './prodTypes-G6W3NUPg.mjs';

type QueryResult = {
    list: Array<{
        period: number;
    } & {
        [key: string]: number | Record<string, number>;
    }>;
};
declare const EventsListResponseSchema: z.ZodObject<{
    list: z.ZodArray<z.ZodObject<{
        id: z.ZodString;
        timestamp: z.ZodNumber;
        feature_id: z.ZodString;
        customer_id: z.ZodString;
        value: z.ZodNumber;
        properties: z.ZodObject<{}, z.core.$strip>;
    }, z.core.$strip>>;
    has_more: z.ZodBoolean;
    offset: z.ZodNumber;
    limit: z.ZodNumber;
    total: z.ZodNumber;
}, z.core.$strip>;
type EventsListResponse = z.infer<typeof EventsListResponseSchema>;

declare const EventsListParamsSchema: z.ZodObject<{
    offset: z.ZodOptional<z.ZodDefault<z.ZodCoercedNumber<unknown>>>;
    limit: z.ZodOptional<z.ZodCoercedNumber<unknown>>;
    featureId: z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString>]>;
    customRange: z.ZodOptional<z.ZodObject<{
        start: z.ZodOptional<z.ZodCoercedNumber<unknown>>;
        end: z.ZodOptional<z.ZodCoercedNumber<unknown>>;
    }, z.core.$strip>>;
}, z.core.$strip>;
type EventsListParams = z.infer<typeof EventsListParamsSchema>;
declare const EventAggregationParamsSchema: z.ZodObject<{
    featureId: z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString>]>;
    groupBy: z.ZodOptional<z.ZodString>;
    range: z.ZodOptional<z.ZodEnum<{
        "24h": "24h";
        "7d": "7d";
        "30d": "30d";
        "90d": "90d";
        last_cycle: "last_cycle";
        "1bc": "1bc";
        "3bc": "3bc";
    }>>;
    binSize: z.ZodOptional<z.ZodDefault<z.ZodEnum<{
        day: "day";
        hour: "hour";
    }>>>;
    customRange: z.ZodOptional<z.ZodObject<{
        start: z.ZodNumber;
        end: z.ZodNumber;
    }, z.core.$strip>>;
}, z.core.$strip>;
type EventAggregationParams = z.infer<typeof EventAggregationParamsSchema>;
type FlatAggregatedRow = {
    period: number;
    [featureName: string]: number;
};
type GroupedAggregatedRow = {
    period: number;
} & {
    [featureName: string]: Record<string, number>;
};
type AggregatedEventRow = FlatAggregatedRow | GroupedAggregatedRow;
declare const EventAggregationTotalSchema: z.ZodRecord<z.ZodString, z.ZodObject<{
    count: z.ZodNumber;
    sum: z.ZodNumber;
}, z.core.$strip>>;
type EventAggregationTotal = z.infer<typeof EventAggregationTotalSchema>;
type EventAggregationResponse = {
    list: AggregatedEventRow[];
    total: EventAggregationTotal;
};

interface AutumnClientConfig {
    backendUrl?: string;
    getBearerToken?: () => Promise<string | null | undefined>;
    customerData?: CustomerData;
    includeCredentials?: boolean;
    betterAuthUrl?: string;
    headers?: Record<string, string>;
    pathPrefix?: string;
    defaultReturnUrl?: string;
    suppressLogs?: boolean;
}
interface IAutumnClient {
    readonly backendUrl?: string;
    readonly prefix: string;
    readonly headers?: Record<string, string>;
    readonly customerData?: CustomerData;
    createCustomer<const T extends readonly CustomerExpandOption[] = readonly []>(params: Omit<CreateCustomerParams<T>, "id" | "data"> & {
        errorOnNotFound?: boolean;
    }): AutumnPromise<ExpandedCustomer<T>>;
    detectCors(): Promise<{
        valid: boolean;
        includeCredentials: boolean | undefined;
    }>;
    shouldIncludeCredentials(): Promise<boolean>;
    getHeaders(): Promise<Record<string, string>>;
    handleFetch(options: {
        path: string;
        method: string;
        body?: any;
    }): Promise<any>;
    post(path: string, body: any): Promise<any>;
    get(path: string): Promise<any>;
    delete(path: string): Promise<any>;
    attach(args: any): Promise<any>;
    checkout(args: any): Promise<any>;
    cancel(args: any): Promise<any>;
    check(args: any): Promise<any>;
    track(args: any): Promise<any>;
    openBillingPortal(args: any): Promise<any>;
    setupPayment(args: any): Promise<any>;
    query(args: any): Promise<any>;
    entities: {
        create(args: any): Promise<any>;
        get(entityId: string, args: any): Promise<any>;
        delete(args: any): Promise<any>;
    };
    referrals: {
        createCode(args: any): Promise<any>;
        redeemCode(args: any): Promise<any>;
    };
    products: {
        list(): AutumnPromise<{
            list: Product[];
        }>;
    };
    events: {
        list(params: EventsListParams): AutumnPromise<EventsListResponse>;
        aggregate(params: EventAggregationParams): AutumnPromise<EventAggregationResponse>;
    };
}
declare class AutumnClient implements IAutumnClient {
    readonly backendUrl?: string;
    protected readonly getBearerToken?: () => Promise<string | null | undefined>;
    readonly customerData?: CustomerData;
    protected includeCredentials?: boolean;
    readonly prefix: string;
    readonly camelCase: boolean;
    readonly headers?: Record<string, string>;
    readonly framework?: string;
    readonly defaultReturnUrl?: string;
    readonly suppressLogs: boolean;
    constructor({ backendUrl, getBearerToken, customerData, includeCredentials, betterAuthUrl, headers, pathPrefix, defaultReturnUrl, suppressLogs, }: AutumnClientConfig);
    /**
     * Detects if the backend supports CORS credentials by making an OPTIONS request
     */
    detectCors(): Promise<{
        valid: boolean;
        includeCredentials: boolean;
    } | {
        valid: boolean;
        includeCredentials: undefined;
    }>;
    /**
     * Automatically determines whether to include credentials based on CORS detection
     */
    shouldIncludeCredentials(): Promise<boolean>;
    getHeaders(): Promise<Record<string, string>>;
    handleFetch({ path, method, body, }: {
        path: string;
        method: string;
        body?: Record<string, unknown> | Record<string, unknown>[];
    }): Promise<Result<any, AutumnError>>;
    post(path: string, body: Record<string, unknown> | Record<string, unknown>[]): Promise<Result<any, AutumnError>>;
    get(path: string): Promise<Result<any, AutumnError>>;
    delete(path: string): Promise<Result<any, AutumnError>>;
    createCustomer<const T extends readonly CustomerExpandOption[] = readonly []>(params: Omit<CreateCustomerParams<T>, "id" | "data"> & {
        errorOnNotFound?: boolean;
    }): AutumnPromise<ExpandedCustomer<T>>;
    attach: (params: {
        productId?: string | undefined;
        entityId?: string | undefined;
        options?: {
            featureId: string;
            quantity: number;
        }[] | undefined;
        productIds?: string[] | undefined;
        freeTrial?: boolean | undefined;
        successUrl?: string | undefined;
        metadata?: Record<string, string> | undefined;
        forceCheckout?: boolean | undefined;
        dialog?: any;
        entityData?: any;
        openInNewTab?: boolean | undefined;
        reward?: string | undefined;
        checkoutSessionParams?: Record<string, any> | undefined;
        newBillingSubscription?: boolean | undefined;
    }) => AutumnPromise<{
        customer_id: string;
        product_ids: string[];
        code: string;
        message: string;
        checkout_url?: string | undefined;
        customer_data?: any;
        invoice?: {
            status: string;
            stripe_id: string;
            hosted_invoice_url: string | null;
            total: number;
            currency: string;
        } | undefined;
    }>;
    checkout: (params: {
        productId?: string | undefined;
        productIds?: string[] | undefined;
        entityId?: string | undefined;
        entityData?: any;
        options?: {
            featureId: string;
            quantity: number;
        }[] | undefined;
        successUrl?: string | undefined;
        openInNewTab?: boolean | undefined;
        dialog?: any;
        forceCheckout?: boolean | undefined;
        freeTrial?: boolean | undefined;
        checkoutSessionParams?: Record<string, any> | undefined;
        reward?: string | undefined;
        newBillingSubscription?: boolean | undefined;
    }) => AutumnPromise<CheckoutResult>;
    cancel: (params: {
        productId: string;
        entityId?: string | undefined;
        cancelImmediately?: boolean | undefined;
    }) => AutumnPromise<{
        success: boolean;
        customer_id: string;
        product_id: string;
    }>;
    check: (params: {
        featureId?: string | undefined;
        productId?: string | undefined;
        entityId?: string | undefined;
        requiredBalance?: number | undefined;
        sendEvent?: boolean | undefined;
        withPreview?: boolean | undefined;
        dialog?: any;
        entityData?: any;
        properties?: Record<string, any> | undefined;
    }) => AutumnPromise<CheckResult>;
    track: (params: {
        featureId?: string | undefined;
        eventName?: string | undefined;
        entityId?: string | undefined;
        value?: number | undefined;
        idempotencyKey?: string | undefined;
        entityData?: any;
    }) => AutumnPromise<{
        id: string;
        code: string;
        customer_id: string;
        feature_id?: string | undefined;
        event_name?: string | undefined;
    }>;
    openBillingPortal: (params?: {
        returnUrl?: string | undefined;
        openInNewTab?: boolean | undefined;
    } | undefined) => AutumnPromise<BillingPortalResult>;
    setupPayment: (params?: {
        successUrl?: string | undefined;
        checkoutSessionParams?: Record<string, any> | undefined;
        openInNewTab?: boolean | undefined;
    } | undefined) => AutumnPromise<SetupPaymentResult>;
    query: (params: {
        featureId: string | string[];
        range?: "24h" | "7d" | "30d" | "90d" | "last_cycle" | "1bc" | "3bc" | undefined;
    }) => AutumnPromise<QueryResult>;
    entities: {
        create: (params: {
            id: string;
            featureId: string;
            name?: string | undefined;
        } | {
            id: string;
            featureId: string;
            name?: string | undefined;
        }[]) => AutumnPromise<Entity | Entity[]>;
        get: (entityId: string, params?: {
            expand?: string[] | undefined;
        } | undefined) => AutumnPromise<Entity>;
        delete: (entityId: string) => AutumnPromise<DeleteEntityResult>;
    };
    referrals: {
        createCode: (params: {
            programId: string;
        }) => AutumnPromise<CreateReferralCodeResult>;
        redeemCode: (params: {
            code: string;
        }) => AutumnPromise<RedeemReferralCodeResult>;
    };
    products: {
        list: () => AutumnPromise<{
            list: Product[];
        }>;
    };
    events: {
        list: (params: {
            featureId: string | string[];
            offset?: number | undefined;
            limit?: number | undefined;
            customRange?: {
                start?: number | undefined;
                end?: number | undefined;
            } | undefined;
        }) => AutumnPromise<{
            list: {
                id: string;
                timestamp: number;
                feature_id: string;
                customer_id: string;
                value: number;
                properties: Record<string, never>;
            }[];
            has_more: boolean;
            offset: number;
            limit: number;
            total: number;
        }>;
        aggregate: (params: {
            featureId: string | string[];
            groupBy?: string | undefined;
            range?: "24h" | "7d" | "30d" | "90d" | "last_cycle" | "1bc" | "3bc" | undefined;
            binSize?: "day" | "hour" | undefined;
            customRange?: {
                start: number;
                end: number;
            } | undefined;
        }) => AutumnPromise<EventAggregationResponse>;
    };
}

interface ErrorResponse {
    message: string;
    code: string;
}
type OmitCustomerType = "id" | "name" | "email" | "fingerprint" | "customer_id";
interface NextAutumnClientConfig {
    encryptedCustomerId?: string;
    customerData?: CustomerData;
    defaultReturnUrl?: string;
}
declare class NextAutumnClient extends AutumnClient {
    private readonly encryptedCustomerId?;
    constructor({ encryptedCustomerId, customerData, defaultReturnUrl }: NextAutumnClientConfig);
    createCustomer<const T extends readonly CustomerExpandOption[] = readonly []>(params: Omit<CreateCustomerParams<T>, "id" | "data"> & {
        errorOnNotFound?: boolean;
    }): AutumnPromise<ExpandedCustomer<T>>;
    getPricingTable(): Promise<any>;
    attach: (params: AttachParams) => AutumnPromise<AttachResult>;
    cancel: (params: CancelParams) => AutumnPromise<CancelResult>;
    check: (params: CheckParams) => AutumnPromise<CheckResult>;
    track: (params: TrackParams) => AutumnPromise<TrackResult>;
    openBillingPortal: (params?: OpenBillingPortalParams | undefined) => Promise<any>;
    entities: {
        create: (params: CreateEntityParams | CreateEntityParams[]) => AutumnPromise<Entity | Entity[]>;
        get: (entityId: string, params?: GetEntityParams) => AutumnPromise<Entity>;
        delete: (entityId: string) => AutumnPromise<DeleteEntityResult>;
    };
    referrals: any;
}

export { type ErrorResponse, NextAutumnClient, type NextAutumnClientConfig, type OmitCustomerType };
