import { A as AppEnv, a as ProductItem, c as ProductItemInterval } from './prodTypes-G6W3NUPg.mjs';
import { z } from 'zod/v4';

declare enum ProductStatus {
    Active = "active",
    Expired = "expired",
    Trialing = "trialing",
    Scheduled = "scheduled",
    PastDue = "past_due"
}
type CustomerExpandOption = "invoices" | "rewards" | "trials_used" | "entities" | "referrals" | "payment_method";

type EntityExpandOption = "invoices";

interface DeleteEntityResult {
    success: boolean;
}
interface GetEntityParams {
    expand?: EntityExpandOption[];
}
interface Entity {
    id: string;
    name: string;
    customer_id: string;
    created_at: number;
    env: string;
    products: CustomerProduct[];
    features: Record<string, CustomerFeature>;
    invoices?: CustomerInvoice[];
}

declare const CoreCusFeatureSchema: z.ZodObject<{
    unlimited: z.ZodOptional<z.ZodBoolean>;
    interval: z.ZodOptional<z.ZodEnum<typeof ProductItemInterval>>;
    balance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    usage: z.ZodOptional<z.ZodNumber>;
    included_usage: z.ZodOptional<z.ZodNumber>;
    next_reset_at: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    overage_allowed: z.ZodOptional<z.ZodBoolean>;
    usage_limit: z.ZodOptional<z.ZodNumber>;
    rollovers: z.ZodOptional<z.ZodObject<{
        balance: z.ZodNumber;
        expires_at: z.ZodNumber;
    }, z.core.$strip>>;
    breakdown: z.ZodOptional<z.ZodArray<z.ZodObject<{
        interval: z.ZodEnum<typeof ProductItemInterval>;
        balance: z.ZodOptional<z.ZodNumber>;
        usage: z.ZodOptional<z.ZodNumber>;
        included_usage: z.ZodOptional<z.ZodNumber>;
        next_reset_at: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>>;
    credit_schema: z.ZodOptional<z.ZodArray<z.ZodObject<{
        feature_id: z.ZodString;
        credit_amount: z.ZodNumber;
    }, z.core.$strip>>>;
}, z.core.$strip>;
type CoreCustomerFeature = z.infer<typeof CoreCusFeatureSchema>;
interface CustomerFeature extends CoreCustomerFeature {
    id: string;
    name: string;
    type: "static" | "single_use" | "continuous_use";
}
interface CustomerReferral {
    program_id: string;
    customer: {
        id: string;
        name: string | null;
        email: string | null;
    };
    reward_applied: boolean;
    created_at: number;
}
interface CustomerProduct {
    id: string;
    name: string | null;
    group: string | null;
    status: ProductStatus;
    started_at: number;
    canceled_at: number | null;
    version: number;
    subscription_ids?: string[] | null;
    current_period_start?: number | null;
    current_period_end?: number | null;
    trial_ends_at?: number;
    entity_id?: string;
    is_add_on: boolean;
    is_default: boolean;
    items: ProductItem[];
}
interface Customer {
    id: string | null;
    created_at: number;
    name: string | null;
    email: string | null;
    fingerprint: string | null;
    stripe_id: string | null;
    env: AppEnv;
    metadata: Record<string, any>;
    products: CustomerProduct[];
    features: Record<string, CustomerFeature>;
    payment_method?: any;
    referrals?: CustomerReferral[];
}
/**
 * Maps expand option strings to their corresponding types.
 * Used for conditional type expansion based on the expand parameter.
 */
interface CustomerExpandedFields {
    invoices: CustomerInvoice[];
    entities: Entity[];
    referrals: CustomerReferral[];
    rewards: unknown;
    trials_used: unknown;
    payment_method: unknown;
}
/**
 * Utility type that creates a Customer with additional expanded fields
 * based on the expand array passed to the API.
 *
 * @example
 * // Base customer without expanded fields
 * type Base = ExpandedCustomer<[]>;
 *
 * // Customer with invoices and entities expanded
 * type WithExpansion = ExpandedCustomer<['invoices', 'entities']>;
 * // Result: Customer & { invoices: CustomerInvoice[]; entities: Entity[] }
 */
type ExpandedCustomer<T extends readonly CustomerExpandOption[] = readonly []> = Customer & {
    [K in T[number]]: CustomerExpandedFields[K];
};
declare const CustomerDataSchema: z.ZodObject<{
    name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    email: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    fingerprint: z.ZodOptional<z.ZodNullable<z.ZodString>>;
}, z.core.$strip>;
type CustomerData = z.infer<typeof CustomerDataSchema>;
declare const CreateCustomerParamsSchema: z.ZodObject<{
    id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    email: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    fingerprint: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    expand: z.ZodOptional<z.ZodArray<z.ZodEnum<{
        invoices: "invoices";
        rewards: "rewards";
        trials_used: "trials_used";
        entities: "entities";
        referrals: "referrals";
        payment_method: "payment_method";
    }>>>;
    stripe_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    auto_enable_plan_id: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
type CreateCustomerParamsBase = z.infer<typeof CreateCustomerParamsSchema>;
/**
 * Generic version of CreateCustomerParams that preserves the expand array type
 * for proper ExpandedCustomer inference.
 */
interface CreateCustomerParams<T extends readonly CustomerExpandOption[] = readonly []> extends Omit<CreateCustomerParamsBase, "expand"> {
    expand?: T;
}
interface BillingPortalResult {
    customer_id: string;
    url: string;
}
interface CustomerInvoice {
    product_ids: string[];
    stripe_id: string;
    status: string;
    total: number;
    currency: string;
    created_at: number;
    hosted_invoice_url: string;
}

export type { BillingPortalResult as B, CustomerData as C, DeleteEntityResult as D, Entity as E, GetEntityParams as G, Customer as a, CustomerExpandOption as b, ExpandedCustomer as c, CreateCustomerParams as d };
